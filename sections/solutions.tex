\documentclass[../main.tex]{subfiles}
\begin{document}
Certains exercices sont vraiment difficiles, et ce n'est qu'en y passant du temps que l'on progresse le plus au niveau du raisonnement et des réflexes. N'hésitez pas !
 
La solution à chaque exercice n'est pas unique. Il est donc possible souvent de trouver une solution qui diffère. Il peut être intéressant de se poser la question de la raison des différences entre deux solutions (optimalité, lisibilité, rigueur, etc\dots). Il n'est ni garanti que les programmes proposés soient optimaux, ni que les démonstrations proposées soient les plus élégantes.

Toute proposition de démonstration ou de code peut être envoyé au contact donné en préface dans l'optique d'amélioration des futures éditions.
\section{Première partie}
On pose pour la suite $\mathcal{B} = \{0, 1\}$ et $N\in\mathbb{N}^{*}$
\subsection{Opérations logiques sur les mots binaires}
\solution{La compréhension pour mieux comprendre} On peut établir un lien entre les opérations logiques élémentaires et les opérations élémentaires en théorie des ensembles (union, union disjointe, intersection, privation). En effet :
\begin{itemize}
	\item $A\cup{B} = \{e\ |\ e\in{A}\vee e\in{B}\}$, on a : $\mathbb{P}(e\in A\cup{B}) = \mathbb{P}(e\in A) + \mathbb{P}(e\in B) - \mathbb{P}(e\in (A\cap B))$
	\item $A\uplus{B} = \{e\ |\ e\in{A}\oplus e\in{B}\}$, on a : $\mathbb{P}(e\in A\uplus{B}) = \mathbb{P}(e\in A) + \mathbb{P}(e\in B) - 2\times\mathbb{P}(e\in (A\cap B))$
	\item $A\cap{B} = \{e\ |\ e\in{A}\wedge e\in{B}\}$, on a : $\mathbb{P}(e\in A\cap{B}) = \mathbb{P}(e\in A)\mathbb{P}(e\in B)$
	\item $\Omega\setminus{A} = \{e\ |\ \neg e\in{A}\}$, on a $\mathbb{P}(e\in{\Omega\setminus{A}}) = 1 - \mathbb{P}(e\in{A})$
\end{itemize}
Il semble donc intuitif de retrouver des expressions semblables :
\begin{itemize}
	\item $\vee\ :\ (a, b) \mapsto a + b - ab$
	\item $\oplus\ :\ (a, b) \mapsto |a - b|$
	\item $\wedge\ :\ (a, b) \mapsto a\times b$
	\item $\neg\ :\ a \mapsto 1 - a$
\end{itemize}
\solution{Universalité des fonctions logiques élémentaires}
On considère un opérateur logique $\ast$ $N$-aire de $\mathcal{B}^{N}$ dans $\mathcal{B}^{M}$ où $M\in{\mathbb{N}^{*}}$. Soit $e\in{\mathcal{B}^{N}}$. On note $\ast(e) = \ast_{M-1}(e)\ast_{M-2}(e)\dots\ast_{0}(e)$. On observe que $\ast$ est entièrement définie par les fonctions $\ast_{i}, i\in{\llbracket0, M-1\rrbracket}$ de $\mathcal{B}^{N}$ dans $\mathcal{B}$.

Montrons donc que toute fonction logique de $\mathcal{B}^{N}$ dans $\mathcal{B}$ peut s'écrire comme une combinaison des fonctions $\vee$, $\wedge$ et $\neg$.

On peut partitionner $\mathcal{B}^{N}$ en deux ensembles disjoints $T$ et $F$ tels que $\ast = \mathbbm{1}_{T}$. C'est-à-dire que $T = \{e\in\mathcal{B}^{N}\ |\ \ast(e) = 1\} = \{t_{1}, \dots, t_{Card(T)}\}$.

D'où, en posant que l'égalité de deux éléments vaut 1 et leur différence vaut 0\footnote{On explicite dans la suite l'expression de $e = t_{i}$.} :
\begin{equation}
	\ast(e) = 1 \Leftrightarrow \displaystyle\bigvee_{i = 1}^{Card(T)}(e = t_i)
\end{equation}
On note $e = e_{N-1}\dots e_{0}$ et pour tout $i\in{\llbracket 1, k\rrbracket}$, $t_{i} = t_{i, N-1}\dots t_{i, 0}$.

On remarque que pour avoir $e = t_{i}$, il faut que :
\begin{itemize}
	\item les 1 de $e$ soient les 1 de $t_{i}$
	\item les 0 de $e$ soient les 0 de $t_{i}$.
\end{itemize}
On note $K_{1}(t_{i}) = \{k\in\{\llbracket 0, N-1\rrbracket\ |\ t_{i, k} = 1\}$ et $K_{0}(t_{i}) = \{k\in\{\llbracket 0, N-1\rrbracket\ |\ t_{i, k} = 0\}$. \\
Alors :
$$
\begin{array}{lcl}
	e = t_i & \Leftrightarrow & \displaystyle\bigwedge_{k\in{K_{1}(t_i)}}(e_k = t_{i, k})\displaystyle\bigwedge_{k\in{K_{0}(t_i)}}(e_k = t_{i, k}) \\
 & & \displaystyle\bigwedge_{k\in{K_{1}(t_i)}}(e_k = 1)\displaystyle\bigwedge_{k\in{K_{0}(t_i)}}(e_k = 0) \\
 & & \displaystyle\bigwedge_{k\in{K_{1}(t_i)}}e_k\displaystyle\bigwedge_{k\in{K_{0}(t_i)}}\neg{e_k}
\end{array}
$$
Finalement, on arrive à la définition par compréhension de $\ast$ :
\begin{displaymath}
\begin{array}{lclcl}
\ast & : & \mathcal{B}^{N} & \rightarrow & \mathcal{B} \\
& & (e_{N-1}, \dots, e_{0}) & \mapsto & \displaystyle\bigvee_{i = 1}^{Card(T)}\left(\displaystyle\bigwedge_{k\in{K_{1}(t_i)}}e_k\displaystyle\bigwedge_{k\in{K_{1}(t_i)}}\neg{e_k}\right)
\end{array}
\end{displaymath}
Les informations de la fonction sont contenues dans $T$.

\textbf{Remarque : }$\mathcal{B}^{N}$ est en bijection avec $\llbracket 0, 2^{N}-1\rrbracket$. Les opérations $\vee$, $\wedge$ et $\neg$ permettent donc de définir n'importe quelle fonction sur $\llbracket 0, 2^{N}-1\rrbracket$ d'arité finie, donc par exemple l'addition, la multiplication, etc\dots\footnote{On utilise évidemment pas cette formule pour définir les opérateurs arithmétiques. Il s'agit seulement de la preuve que ces opérateurs logiques sont capables de telles définitions.}
\begin{minitelbasicbox}{À propos des formes normales}
Dans l'expression précédente, les $e_{k}$ sont appelées des variables propositionnels en logique propositionnelle (ou d'ordre 0). Elles n'ont que deux interprétations possibles, \textit{Vrai} ou \textit{Faux}, 1 ou 0. La proposition logique associée à l'expression de la fonction logique admet des valeurs de vérités qui sont les couples $V = (v_{N-1}, \dots, v_{0})$ appelés \textit{interprétations} tels que $\ast(V) = Vrai$.

On peut montrer qu'une proposition logique en logique propositionnelle peut s'écrire de manière équivalente sous deux formes :
\begin{itemize}
	\item la forme normale disjonctive qui est une disjonction de conjonctions de variables :
	$$\displaystyle\bigvee\left(\displaystyle\bigwedge x_{i}\right)$$
	\item la forme normale conjonctive qui est une conjonction de disjonctions de variables :
	$$\displaystyle\bigwedge\left(\displaystyle\bigvee x_{i}\right)$$
\end{itemize}
En électronique, ces deux formes sont nommés respectivement \textit{somme de produits} et \textit{produit de sommes} en raison des expressions trouvés à l'\refexercise{La compréhension pour mieux comprendre}.
\end{minitelbasicbox}
\solution{Porte NAND}
La table de vérité de NAND est :
\begin{center}
\begin{tabular}{c|c|c}
$A$ & $B$ & $A\uparrow{B}$ \\
\hline
0 & 0 & 1 \\
0 & 1 & 1 \\
1 & 0 & 1 \\
1 & 1 & 0 \\
\end{tabular}
\end{center}
On a ensuite pour tout $a, b\in{\mathcal{B}}$ :
\begin{itemize}
	\item $\neg(a) = a\uparrow{a}$
	\item $a\wedge b = \neg{a\uparrow{b}} = (a\uparrow{b})\uparrow(a\uparrow{b})$
	\item $a\vee b = \neg{(\neg a \wedge \neg{b})} = \neg{a}\uparrow\neg{b} = (a\uparrow a) \uparrow (b\uparrow b)$
\end{itemize}
\solution{Porte NOR}
La table de vérité de NOR est :
\begin{center}
\begin{tabular}{c|c|c}
$A$ & $B$ & $A\uparrow{B}$ \\
\hline
0 & 0 & 1 \\
0 & 1 & 0 \\
1 & 0 & 0 \\
1 & 1 & 0 \\
\end{tabular}
\end{center}
On a ensuite pour tout $a, b\in{\mathcal{B}}$ :
\begin{itemize}
	\item $\neg a = a\downarrow a$
	\item $a \vee b = \neg{(a \downarrow b)} = (a\downarrow b) \downarrow (a\downarrow b)$
	\item $a\wedge b = (\neg a)\downarrow (\neg b) = (a\downarrow a) \downarrow (b\downarrow b)$
\end{itemize}
\solution{Petit retour à l'algèbre fondamentale} Comme $\oplus$ est une opération \textit{bit à bit}, il suffit de vérifier que $G = (\mathcal{B}, \oplus)$ est un groupe commutatif.
\begin{itemize}
	\item $\oplus$ est une fonction de $\mathcal{B}^{2}$ dans $\mathcal{B}$ il s'agit bien d'une loi de composition interne.
	\item On observe que $0\oplus0 = x$ et $0\oplus 1 = 1$ et $1\oplus 0 = 1$. Donc $0$ est un élément neutre par $\oplus$. Comme $1\oplus1 = 0$, 0 est le seul élément neutre.
	\item $\oplus$ est associative
	\item Pour tout $x\in{\mathcal{B}}$, $x\oplus x = 0$ donc $x^{-1} = x$
	\item $\oplus$ est commutative
\end{itemize}
Donc $G$ est bien un groupe commutatif.

\solution{Inversibilité des décalages} Les décalages ne sont pas inversibles. En effet, quand des bits sont supprimés par un décalage de trop de bits, l'information est perdue. Un décalage dans l'autre sens ne produit que des 0. Par exemple : $(01000 \ll 2) \gg 2 = 00000 \neq 01000$
\subsection{Opérations arithmétiques}
\solution{Du décimal au binaire} 

\begin{minipage}{0.5\textwidth}
\begin{itemize}
	\item $(01001100)_{2}$
	\item $(10111100)_{2}$
	\item $(00100001)_{2}$
	\item $(01101101)_{2}$
	\item $(01011100)_{2}$
\end{itemize}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\begin{itemize}
	\item $(11010011)_{2}$
	\item $(00000100)_{2}$
	\item $(11101110)_{2}$
	\item $(10100001)_{2}$
	\item $(01111110)_{2}$
\end{itemize}
\end{minipage}
\subsection{Opérations sur les nombres à virgules}
\solution{Écriture en base 2 de nombres non entiers}
\begin{itemize}
	\item $(1110.1001)_2$
	\item $(1.01101)_2$
	\item $(111.0111)_2$
	\item $(0.0001001\underline{001}\dots)_2$ : il existe un nombre infini de décimales. On a le même phénomène avec la représentation de $\frac{1}{3}$ en décimal.
\end{itemize}
\solution{Racine carrée inverse rapide (1)} \\
On note $P = x^2 + y^2 + z^2$. Pour simplifier les notations, on note pour $x\in\mathbb{R}$ :
\begin{itemize}
	\item $itof(x) = btof(btoi^{-1}(x))$
	\item $ftoi(x) = btoi_s(ftob(x))$
\end{itemize}
On utilise ici trois résultats :
\begin{flalign}
    &log_2\left(\dfrac{1}{\sqrt{P}}\right) = -\frac{1}{2}log_2(P)\label{eq:log2}\\
    &\forall x\in\mathbb{R}_{f32},\ x = itof\left(A^{-1}(log_2(x) - B)\right)\label{eq:x_itof}\\
    &\forall x\in\mathbb{R}_{f32},\ log_2(x) = Aftoi(x) + B\label{eq:x_ftoi}
\end{flalign}
En utilisant l'égalité \eqref{eq:log2} dans \eqref{eq:x_itof} en $x = \frac{1}{\sqrt{P}}$, on obtient :
$$\frac{1}{\sqrt{P}} = itof\left(-\frac{1}{2A}(log_2(P) + 2B)\right)$$
En injectant \eqref{eq:x_ftoi}, on a alors :
$$\frac{1}{\sqrt{P}} = itof\left(-\frac{1}{2}ftoi(P) - \frac{3B}{2A}\right)$$
\subsection{Représentation hexadécimale}
\solution{Conversion binaire-hexadécimale}
\begin{itemize}
	\item $713705 = (1010\ 1110\ 0011\ 1110\ 1001)_{2} = 0\textsf{xAE}3\textsf{E}9$
	\item $8.8 = (1.00011001001001001001001)_{2}\times 2^{3} = 0100\ 0001\ 1000\ 1100\ 1001\ 0010\ 0100\ 1001 = 0\textsf{x}418\textsf{C}9249$
	\item $42 = (0001\ 1010)_{2} = 0\textsf{x}1\textsf{A}$
	\item $-1.1 = -(1.00010010010010010010010)_2\times{2^1} = 1100\ 0000\ 0000\ 1001\ 0010\ 0100\ 1001\ 0010 = 0\textsf{xC}0092492$
	\item $101 = (0110\ 0101)_2 = 0\textsf{x}65$
\end{itemize}
\subsection{Caractères ASCII}
\solution{Traduction ASCII 1} La chaîne de caractères décrite est : 
\begin{center}
``Minitel = GOAT''
\end{center}
\solution{Traduction ASCII 2} Le mot binaire qui décrit cette chaîne est :
$$\textsf{0x4F6820210A5175692065732D74752021083F}$$
\section{Deuxième partie}
\subsection{Bases du langage}
\subsubsection{Variables}
\solution{Interversion de variables par effet de bord}
\inputminted{c}{solutions/inter_var_side_effect.c}
\subsubsection{Formatage de chaînes de caractères}
\solution{Taille des types}
\inputminted{c}{solutions/taille_types.c}
\subsubsection{Opérateurs sur les variables}
\solution{Valeur}
 
Le premier code est strictement équivalent au code suivant :
\begin{minted}{c}
int i = 10;
i = i - i;
i--;
\end{minted}
D'où $i = -1$ en fin d'exécution. 
Le second code est strictement équivalent au code suivant :
\begin{minted}{c}
int i = 10;
i--;
i = i - i;
\end{minted}
D'où $i = 0$ en fin d'exécution.
 
\solution{Calcul d'expressions}
\begin{itemize}
	\item $a = 55$
	\item $b = 41$
	\item $c = 93$ (on évalue d'abord la division)
	\item $d = 65522$ ($93 - 107 = 0 - 14 \equiv 65535 - 13 [65536]$)
\end{itemize}
\solution{Priorité des opérateurs}
\begin{minted}{c}
int a = 6, b = 12, c = 24;
a = 25*12 + b;
printf("%d", a > 4 && b == 18);
(a >= 6&&b < 18) || c != 18;
c = a = b + 10;
\end{minted}
\solution{Interversion sans effet de bord (1)}
\inputminted{c}{solutions/inter_no_side_effect_1.c}
On note $a_{p}$ et $b_{p}$ les valeurs de $a$ et $b$ précédent l'interversion, et $a_{s}$ et $b_{s}$ les valeurs de $a$ et $b$ succédant à l'interversion.  
Les opérateurs $+$ et $-$ conservent l'écriture binaire des mots. L'échange est donc correct quelques soient les signatures de $a$ et $b$. 
Avec $a$ sur $N_{a}$ bits et $b$ sur $N_{b}$ bits avec $N_{a} > N_{b}$, on peut choisir $a = 2^{N_{b}}$ et $b$ quelconque. Alors $a + b = 2^{N_{b}}+b$ puis $b_{s} = 2^{N_{b}}+b_{p} - b_{p} = 2^{N_{b}} = -1 \neq{a}$. La permutation est donc incorrecte.
 
Cela peut être justifié sans calcul par l'observation suivante : les bits $a_{N_{a}-1}\dots a_{N_b}$ sont perdus par la modulation par $2^{N_{b}}$. La permutation ne peut donc être correcte.
 
\solution{Interversion sans effet de bord (2)}
\inputminted{c}{solutions/inter_no_side_effect_2.c}
En effet, on rappelle que pour tout ${x\in{\mathcal{B}^{N}}}$, $x\oplus{x} = 0$ et $x\oplus{0} = x$. Ainsi, $b_{s} = a\oplus{b}\oplus{b} = a$ et $a_{s} = a\oplus{b}\oplus{a} = b$.
 
\solution{Multiplication par décalage} On observe que $14 = (1110)_{2} = 2^{3} + 2^{2} + 2^{1} = (1 \ll 3) + (1 \ll 2) + (1 \ll 1)$. Il est toutefois possible de faire mieux en prêtant plus attention à la représentation binaire de 14. En effet, $14 + 1 = (1111)_{2} = 16 - 1$, c'est-à-dire $14 = 16 - 2 = 2^{4} - 2^{1} = (1 \ll 4) - (1 \ll 1)$
\inputminted{c}{solutions/mult_decalage.c}
Il est ainsi possible, parfois, d'optimiser l'opération de multiplication grâce à cette technique. La méthode classique de la multiplication est en effet plus lente à calculer, bien que plus générale. Cela est particulièrement visible lors de la multiplication de grands nombres :
$$987654321\times{65534} = (987654321 \ll 16) - (987654321 \ll 1)$$
Seules 2 décalages et une soustraction sont effectuées ($65534 = 65536 - 2 = 2^{16} - 2^{1}$)
 
\solution{Valeur absolue (1)}On utilise la particularité qu'un décalage logique (effectué sur \textsf{unsigned int}) n'effectue pas d'extension du signe :
\inputminted{c}{solutions/valeur_absolue.c}
Par ailleurs, $-1 = 0\textsf{xFFFFFFFF}$, donc \textsf{-1 \& x == x} est toujours vrai et \textsf{0 \& x == 0} est toujours vrai.
\subsubsection{Projection de type}
\solution{Quelques évaluations entières}
\begin{enumerate}
	\item \textit{vraie} car $0\textsf{xFFFFFFFF} + 1 = 0$ ($e1$ est sur 32 bits)
	\item \textit{faux} car $\textsf{(unsigned char)(-1)} = 255 = 0\textsf{xFF}$, d'où l'expression est égale à 0.
	\item \textit{vraie} car on a \textsf{!(e1 == e2)} $\equiv$ \textsf{e1 != e2} qui est vraie.
	\item \textit{vraie} car $64\wedge{e3} = 65 \equiv 1[8]$. D'où $\textsf{!(((64 $\wedge$ e3) \% 8) - 1)} = 1$.\newline Alors : $e4 \equiv{\textsf{(unsigned char)(257) - 2}} = -1$
\end{enumerate}
\subsubsection{Structures de contrôle du flot d'exécution}
\solution{}
\inputminted{c}{solutions/cours_structure_controle.c}
À partir de $u_{4}$ inclut, les valeurs de la suite sont fausses. On observe ainsi que $u_{3} = 808602$, d'où $u_{4} = 3\times808602^{2} - 5\times{808602} + 2 = 1961507540204 > 2^{31} - 1 = 2147483647$. Il y a un dépassement de capacité car la variable $u$ est stocké sur trop peu de bits. Le résultat est donc correct modulo $2^{32}$
 
\solution{Question d'âge}
\inputminted{c}{solutions/question_d_age.c}
\solution{Suite de Fibonacci}
\inputminted{c}{solutions/suite_fibonacci_1.c}
\solution{Test de primalité}\newline
Par définition, un nombre $n$ est premier si il possède exactement deux diviseurs distincts : $n$ et $1$. On peut donc tester la primalité d'un nombre en vérifiant qu'il ne possède pas d'autres diviseurs positifs strictement supérieurs à 1 que lui-même. Un premier algorithme naïf\footnote{Enfin, pas tout à fait puisqu'en ignorant les nombres pairs, on obtient seulement $\dfrac{N}{2}$ tours. Mais cela est équivalent asymptotiquement (les constantes restant des constantes).} est donc le suivant :
\inputminted{c}{solutions/primal_test.c}
Considérons maintenant un diviseur $d$ de $n$. Il existe donc $q$ tel que $n = dq$. On observe que si $d \geq \sqrt{n}$ alors $q \leq{\sqrt{n}}$. Par ailleurs, $q$ est un diviseur de $n$ lui aussi. Supposons que l'on ait vérifié que pour tout $1 < m \leq \sqrt{n}$, $m\nmid{n}$, alors il est absurde qu'il existe un diviseur de $n$ supérieur strictement à $\sqrt{n}$ car il existerait alors un diviseur $d$ strictement inférieur à $\sqrt{n}$.
 
Il suffit donc de vérifier la divisibilité de $n$ par les entiers impairs $m\leq{\sqrt{n}}$ :
\begin{minted}[firstnumber=10]{c}
for (int i = 3; i*i <= N && is_primal; i += 2) {
	is_primal = (N % i == 0) ? 0 : is_primal;
}
\end{minted}
On a $\dfrac{n}{\sqrt{n}}\underset{n\rightarrow{\infty}}{\rightarrow}\infty$, l'algorithme est donc plus efficace (il ne s'agit pas d'une constante).
\subsubsection{Routines}
\solution{Encore Fibonacci}
\inputminted{c}{solutions/suite_fibonacci_2.c}
\solution{Puissances entières}
\inputminted{c}{solutions/int_pow.c}
On observe que $(2^{31}-1)^{2^{32}-1}\approx{2^{31\times{2^{32}}}}$ est très largement supérieur à $2^{63} - 1$ qui est la valeur maximale d'un \textsf{long int}. En fait, pour stocker le résultat maximal de la fonction \textsf{pow}, il faudrait un disque dur d'environ $4\times{31} = 124\ Go$. Par ailleurs, la fonction \textsf{pow} reste infiniment loin d'être surjective dans $\mathbb{Z}$.
\subsubsection{Pointeurs}
\solution{Quelques procédures inutiles pour devenir un bot efficace}
\inputminted{c}{solutions/become_bot.c}
\solution{Interversion sans effet de bord (3)}
\inputminted{c}{solutions/inter_no_side_effect_3.c}
En effet, si $x = y$, à la première ligne, on a $*x = *x ^ *x = 0$, et $*y = *x = 0$. Les autres lignes sont inutiles, mais chacune a le même effet que la première.

\solution{Distance de Manhattan}
Le type \textsf{double} est sur $8 = 2\times{4}$ octets. Il permet donc de stocker deux nombres de type \textsf{float}.

Si $x$ est une variable de type \textsf{double}, $\&x$ est aussi l'adresse des premiers 4 octets, et $\&x + 4$ est \textit{mathématiquement} l'adresse des seconds 4 octets. Il faut toutefois faire attention. En C, $\&x$ est de type \textsf{double}. Si on veut lui ajouter 4, il faut le projeter en un pointeur de type sur 4 octets, et ajouter 1 à ce pointeur :
\begin{minted}{c}
double x; // 8 octets
float *x_left = (float*)&x; // pointeur sur 4 octets de gauche
float *x_right = (float*)&x + 1; // pointeur sur 4 octets de droite
\end{minted}
\inputminted{c}{solutions/manhattan_dist.c}
\solution{Valeur absolue (2)}
On veut simplement modifier le bit de signe. Toutefois, les opérations bit-à-bits sont interdites sur les nombres à virgules.

Les projections classiques \textsf{float x = (float)n;} et \textsf{int n = (int)x;} modifient la représentation binaire, ce qui n'est pas souhaité. On utilise à la place une idée semblable à celle utilisée pour l'\refexercise{Distance de Manhattan} :
\begin{minted}{c}
float abs(float x) {
	int int_x = *((int*)&x); // réinterprétation entière
	int_x &= 0x7FFFFFFF;	
	float abs_x = *((float*)&int_x); // réinterprétation flottante
	return abs_x;
}
\end{minted}
\solution{Racine carrée inverse rapide (2)}
La première étape est de déterminer la projection de type à effectuer pour calculer les fonctions :
\begin{itemize}
	\item $itof(x) = btof(btoi^{-1}(x))$
	\item $ftoi(x) = btoi_s(ftob(x))$
\end{itemize}
On utilise la même technique que pour l'\refexercise{Valeur absolue (2)} :
\begin{minted}{c}
float fast_inverse_square_root(float x) {
	int n = *((int*)&x);
	// transformation
	float y = *((float*)&n);
	return y;
}
\end{minted}
On a $A = \textsf{0x340003ce}$ et $B = \textsf{0xc2fe000f}$ interprétés comme des nombres flottants, d'où $-\frac{3B}{2A} = \textsf{0x4ebe7a62}$ selon la norme \textit{IEEE 754}. La difficulté est donc de trouver le mot binaire correspondant à la projection entière de $-\frac{3B}{2A}$ :
\begin{minted}{c}
int binary = 0x4ebe7a62;
float float_interpretation = *(float*)&binary;
int projection = (int)(float_interpretation);
printf("%x\n", projection);
\end{minted}
donne le mot binaire \textsf{0x5f3d3100}. Finalement :
\begin{minted}{c}
float fast_inverse_square_root(float x) {
	int n = *((int*)&x);
	n = 0x5f3d3100 - (n >> 1);
	float y = *((float*)&n);
	return y;
}
\end{minted}
On obtient $\frac{1}{\sqrt{0.01}} = 10 \approx 10.70$. L'erreur est assez élevé. En effet, la projection entière de \textsf{0x4ebe7a62} comporte une imprécision supplémentaire qui s'ajoute à celle de $log_2$.

On peut améliorer la précision en balayant les projections entières adjacentes. Avec \textsf{0x5f31eb85}\footnote{Le jeu \textit{Quake III utilise la constante \textsf{0x5f3759df}, mais utilise la méthode Newton. La constante doit aussi s'adapter à ça pour de meilleurs résultats.}}, on obtient une erreur de moins de $0.1\%$. Cette précision peut encore être améliorée en utilisant la \href{https://fr.wikipedia.org/wiki/M%C3%A9thode_de_Newton}{méthode de Newton}. 
\subsubsection{Interagir avec les flux standards}
\solution{Distance Euclidienne}
\inputminted{c}{solutions/euclidian_dist.c}
\solution{Somme d'entiers}
\inputminted{c}{solutions/int_sum.c}
\solution{Jeu du plus ou moins}
\inputminted{c}{solutions/plus_ou_moins.c}
La stratégie optimale est identique à celle de l'\refexercise{Recherche dichotomique} pour les mêmes raisons. Il faudra au maximum $\lceil log_2(N)\rceil$ tentatives pour trouver le nombre mystère.
\subsubsection{Tableaux statiques}
\solution{Les routines, direction la seconde classe !} Une fonction ne peut pas être construite pendant l'exécution du programme en C\footnote{Enfin, en assembleur on peut, mais là n'est pas le sujet, ce n'est plus du C.}.

\solution{Routines classiques de manipulation de tableaux}
\inputminted{c}{solutions/tab_select_sort.c}
On pose pour $i\in\llbracket 0; l(T)\rrbracket$ l'hypothèse de récurrence $P(i)$ : \textit{\og après le $i^e$ tour de boucle, on a les invariants suivants :
\begin{itemize}
	\item $T[0:i]$ est trié dans l'ordre croissant
	\item $T[0:i]$ contient les $i$ plus petits éléments de $T$.
\end{itemize}
\fg}

\underline{Initialisation} : le tableau $T[0:0]$ est vide. Les deux propositions constitutives de $P(0)$ sont trivialement vraies.

\underline{Hérédité} : Soit $i\in\llbracket 0; l(T) - 1\rrbracket$. Supposons $P(i)$. Au $(i + 1)^e$ tour de boucle, on a $i_{min}$ l'indice de l'élément minimal dans $T[i:l(A)]$. Par HR, tous les éléments de $T[0:i]$ sont inférieurs à ceux de $T[i:l(A)]$ et donc à $T[i + i_{min}]$. Après le $(i+1)^e$ tour de boucle, on a échangé $T[i]$ et $T[i + i_{min}]$ donc $T[0:i+1]$ contient des éléments tous inférieurs à ceux de $T[i+1:l(A)]$ et $T[i]$ majore $T[0:i+1]$ qui est donc trié par ordre croissant. \newline
Donc les deux propositions de $P(i+1)$ sont vraies.

\underline{Conclusion} : L'hypothèse de récurrence est initialisée et héréditaire. Donc par principe de raisonnement par récurrence, pour tout $i\in\llbracket 0; l(T)\rrbracket$, $P(i)$ est vraie.

En particulier, pour $i = l(T)$, d'après le premier invariant, le tableau $T[0:l(T)] = T$ est trié à la fin de l'exécution de l'algorithme.

\solution{Recherche dichotomique}

\textbf{Question 1 :} La démonstration est presque triviale. Supposons que $x\in T$. Il existe donc $i_x\in \llbracket{0; l(T)-1}\rrbracket$ tel que $T[i_x] = x$. 
\begin{itemize}
	\item Supposons $x\leq T[i]$. Comme $T$ est trié par ordre croissant, $i_x \leq i$
	\item Supposons $x > T[i]$. Comme $T$ est trié par ordre croissant, $i_x > i$ 
\end{itemize}
\textbf{Question 2 :} À chaque tour de boucle, on pose $i_m = \left\lfloor \frac{l(T)}{2}\right\rfloor$, et alors :
\begin{itemize}
	\item si $l(T) = 0$, renvoyer \textit{Faux}
	\item si $l(T) = 1$ et $T[0] = x$, renvoyer \textit{Vrai}
	\item si $x\leq T[i_m]$, $T\leftarrow T[0; i_m]$ et boucler
	\item si $x > T[i_m]$, $T\leftarrow T[i_m:l(T)]$ et boucler
\end{itemize}
Grâce au choix de $i_m$ effectué, on divise par deux la taille du tableau. Après au maximum $\lceil log_2(l(T))\rceil$ étapes, on a $l(T) \leq 1$ et le programme termine.
\inputminted{c}{solutions/dichotomique.c}
\solution{Liste des nombres premiers} 
TODO
% \textbf{Questions 1 et 2 :}
% La structure du code est la même dans les deux cas :
% \begin{minted}{c}
% #include <stdio.h>

% #define N ...

% char primal_test(unsigned int n, unsigned int primes[], unsigned int counter);

% int main() {
% 	unsigned int primes[N];
% 	unsigned int i = 3;
% 	unsigned int counter = 0;
% 	primes[0] = 2;
% 	while (i <= N) {
% 		if (primal_test(i, primes, counter)) {
% 			primes[++counter] = i;
% 			printf("%u;", primes[counter]);
% 		}
% 		i += 2;
% 	}
% }
% \end{minted}
% Les paramètres $primes$ et $counter$ sont inutiles pour la première question :
% \begin{minted}{c}
% char primal_test(unsigned int n, unsigned int primes[], unsigned int counter) {
% 	char is_primal = n == 2 || (n > 2 && n % 2 != 0); // nécessaire
% 	for (int i = 3; i*i <= n && is_primal; i += 2) {
% 		is_primal = (n % i == 0) ? 0 : is_primal;
% 	}
% 	return is_primal;
% }
% \end{minted}
% Pour la seconde :
% \begin{minted}{c}
% char primal_test(unsigned int n, unsigned int primes[], unsigned int counter) {
% 	char is_primal = 1; // premier par défaut
% 	for (unsigned int k = 0; k <= counter && is_primal && primes[k] * primes[k] <= i; k++) {
% 		is_primal = (i % primes[k] == 0 ? 0 : is_primal);
% 	}
% 	return is_primal;
% }
% \end{minted}
% \textbf{Question 3 :} L'algorithme décrit ne suit pas la même structure. Cette structure semble seulement plus complexe à écrire pour aboutir au même résultat. On montre à la dernière question que tel n'est pas le cas et que le crible d'Eratosthène est plus rapide que l'algorithme "naïf" précédent.
% \inputminted{c}{solutions/eratosthene.c}
% \textbf{Question 4 :}
% Comparons avec l'algorithme précédent, il faut d'abord déterminer le nombre de tours de boucle effectué par le test de primalité :

% Si $n, p\in\mathbb{N}$ avec $p$ premier, en se restreignant au groupe $\dfrac{\mathbb{Z}}{p\mathbb{Z}}$, $\mathbb{P}(p\ |\ n) = \dfrac{1}{p}$ (car il n'y a qu'un élément égal à 0 modulo $p$ dans un ensemble à $p$ éléments). Si on sait que $n$ n'est pas divisible par $p_2$ un autre nombre premier, on sait qu'une autre des valeurs de $\dfrac{\mathbb{Z}}{p\mathbb{Z}}$ ne peut être prise par $n$. Ainsi, $\mathbb{P}_{(p_{2}\ \nmid\ n)}(p\ |\ n) = \dfrac{1}{p-1}$. On note $B_N$ la variable aléatoire dénotant le nombre de tours de boucle atteint par le programme pour le test de primalité de l'entier $N$. Alors, la probabilité que le test de primalité effectue $k\in{\llbracket1; \pi(n)\rrbracket}$  tours de boucle est :
% $$\mathbb{P}(B_N = k) = \mathbb{P}_{\left(\bigcap_{j=1}^{k-1}(p_j\ \nmid\ n)\right)}(p_k\ |\ n)\displaystyle\prod_{i = 1}^{k-1}\mathbb{P}_{\left(\bigcap_{j=1}^{i-1}(p_j\ \nmid\ n)\right)}(p_i\ \nmid\ n)\text{, où }p_{i}\text{ désigne le }i^e\text{ premier nombre premier}$$
% C'est-à-dire :
% $$\mathbb{P}(B_N = k) = \dfrac{1}{p_k - k}\displaystyle\prod_{i = 1}^{k-1}\dfrac{p_i - i}{p_i - i + 1}\text{, où }p_{i}\text{ désigne le }i^e\text{ premier nombre premier}$$
% L'espérance du nombre de tours de boucle atteint est donc :
% $$\mathbb{E}(B_N) = \displaystyle\sum_{k = 1}^{\pi(N)}\dfrac{k}{p_k - k}\prod_{i = 1}^{k-1}\left(1 - \dfrac{1}{p_i - i + 1}\right)$$
% Comme pour $i \geq 2$, on a $p_i \geq i.ln(i)$, alors :
% $$\mathbb{E}(B_N) \geq \displaystyle\sum_{k = 1}^{\pi(N)}\dfrac{k}{2(p_k - k)}\prod_{i = 2}^{k-1}\dfrac{i.ln(i)}{i.ln(i) + 1}$$

% On observe que $\sqrt{N}$ minore $\displaystyle\sum_{k = 1}^{\pi(N)}\dfrac{ln(k)}{\sqrt{k}}$ à partir d'un certain rang. En effet, par comparaison série intégrale :
% $$\begin{array}{lcll}
% \displaystyle\sum_{k = 2}^{\pi(N)}\dfrac{ln(k)}{\sqrt{k}} & \geq & \displaystyle\int_{1}^{\pi(N)}\dfrac{ln(x)}{\sqrt{x}}\mathrm{d}x \\
%  & \geq & \sqrt{\frac{N}{ln(N)}}(2(ln(N) - ln(ln(N))) - 4) + 4 & \text{ car }\pi(N)\geq \frac{N}{ln(N)} \\
%  & \sim_{+\infty} & 2\sqrt{Nln(N)}
% \end{array}$$
% et donc plus grand que $\sqrt{N}$ à partir d'un certain rang. Ainsi, si à partir d'un certain rang, la suite des $\frac{ln(k)}{\sqrt{k}}$ minore  la suite des $\frac{1}{2(p_k - k)}k\displaystyle\prod_{i = 2}^{k-1}\dfrac{i.ln(i)}{i.ln(i) + 1}$, alors le test de primalité est plus lent que celui en $\sqrt{N}$, et on  a donc $T(N) > N^{\frac{3}{2}}$ à partir d'un certain rang.

% On veut ainsi montrer qu'à partir d'un certain rang :
% $$\frac{1}{2(p_k - k)}k^{\frac{3}{2}}\displaystyle\prod_{i = 2}^{k-1}\dfrac{i.ln(i)}{i.ln(i) + 1} \geq ln(k)$$
% On pose $C = \frac{1}{2}\frac{2.ln(2)}{2.ln(2) + 1}$.

% On remarque que pour $i \geq 3$, $\dfrac{iln(i)}{iln(i) + 1}\geq \dfrac{iln(i)}{(i+1)ln(i+1)}$
% D'où :
% $$\begin{array}{lcll}
% Ck^{\frac{3}{2}}\displaystyle\prod_{i = 3}^{k-1}\dfrac{i.ln(i)}{i.ln(i) + 1} & \geq & C\dfrac{k^{\frac{3}{2}}}{p_k - k}\times\dfrac{3ln(3)}{kln(k)} & \text{ par produit télescopique} \\
% & \geq & C'\dfrac{\sqrt{k}}{ln(k)} & \text{ où }C'=3ln(3)C
% \end{array}$$
% Comme $$\dfrac{\sqrt{k}}{ln^{2}(k)}\underset{k\rightarrow+\infty}{\rightarrow}+\infty$$, on a bien l'inégalité recherchée à partir d'un certain rang.
\subsubsection{Tableaux dynamiques}
\solution{Conversion en binaire}
\inputminted{c}{solutions/nat2bin.c}
\subsubsection{Tableaux multidimensionnels}
\solution{Afficher un tableau \textit{2d}}
\inputminted{c}{solutions/tab_display_2d.c}
\solution{Affichage du triangle}\newline
Version généralisée pour \textsf{N\_LINES} quelconque : 
\inputminted{c}{solutions/triangle.c}
\solution{Matrices (1)} \newline
Soit $m$ une matrice implantée en C. Il faut d'abord déterminer ce que signifie $mat[i] \equiv ^*((char^*)m + i\times sizeof(double^*))$. Le $double^*$ est le type d'une ligne. Donc $l_{i} = mat[i]$ est le pointeur vers la $i^{e}$ ligne. On a alors $l_{i}[j]$ le $j^e$ élément de la $i^e$ ligne. En remplaçant $l_{i}$ par son expression, on a :
$$mat[i][j] \equiv\ ^*(^*(mat + i) + j) \equiv (^*((char^*)mat + i\times sizeof(double^*)) + j\times sizeof(double)) $$
\inputminted{c}{solutions/matrix.c}
\subsubsection{Structures}
\solution{Matrices (2)} \newline
Il suffit d'utiliser l'interface suivante, les modifications des routines sont assez triviales :
\inputminted{c}{solutions/matrix.h}
\solution{Optimisation d'alignement}
Avec un \textsf{double} à la place d'un \textsf{int} :
\begin{itemize}
	\item $\textsf{sizeof(struct ExampleUnaligned)} = 24$
	\item $\textsf{sizeof(struct ExampleAligned)} = 16$
\end{itemize}
\solution{Listes chaînées}
\inputminted{c}{solutions/linkedlist_1.c}
\subsubsection{Modulation et entêtes}
\solution{Un module de listes chaînées} \newline
On écrit le code des fonctions de l'exercice précédent dans un fichier \textit{``linkedlist.c''}\footnote{Dans le répertoire de travail du fichier \textit{``main.c''}} que l'on fait débuter par la ligne \textsf{\#include "linkedlist.h"}. On écrit ensuite dans le même répertoire de travail le fichier \textit{``linkedlist.h''} suivant, qui contient les prototypes et les structures :
\inputminted{c}{solutions/linkedlist_2.h}
Il conserve la même fonction \textsf{main} du fichier \textit{``main.c''} avec une inclusion du module :
\inputminted{c}{solutions/linkedlist_2.c}
Et compilation puis exécution :
\begin{minted}[frame=single]{bash}
user@computer ~/working_directory> gcc main.c linkedlist.c -o main
user@computer ~/working_directory> ./main
->4->5->6
user@computer ~/working_directory>
\end{minted}
\solution{Calculatrice}
\inputminted{c}{solutions/calculatrice.c}
\solution{AtoI}
\inputminted{c}{solutions/atoi.c}
\subsubsection{Interagir avec les flux de fichiers}
\subsection{Concepts avancés}
\subsubsection{Passage d'arguments au programme}
\solution{Liste des arguments}
\inputminted{c}{solutions/list_args.c}
\solution{Un cat minimaliste}
\inputminted{c}{solutions/cat.c}
\subsubsection{Pointeurs de routines}
\solution{Mapping}
\inputminted{c}{solutions/mapping.c}
\subsubsection{Directives du préprocesseur (2)}
\solution{Tout dépend du système}
\begin{minted}{c}
#include <stdio.h>
#include <stdlib.h>

int main() {
	#if defined(__linux__)
	printf("Chouette !\n");
	#elif defined(_WIN32)
	printf("Beeerk !\n");
	#endif
	return EXIT_SUCCESS;
}
\end{minted}
\solution{Libération sécurisée}
\begin{minted}[linenos=false]{c}
#define safe_free(p) do {free((void*)p);p = NULL;} while(0)
\end{minted}
\subsubsection{Routines variadiques}
\solution{À un doigt du zéro}
\inputminted{c}{solutions/un_doigt_du_zero.c}
\end{document}