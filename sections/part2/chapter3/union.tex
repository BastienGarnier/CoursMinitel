\documentclass[../../../main.tex]{subfiles}
\begin{document}
\subsection{Motivation par un exemple}
Il arrive régulièrement en programmation de manipuler des structures de données dont seules certains
champs seront utilisés à un instant donné. Par exemple, on peut vouloir coder une structure stockant
les données d’un évènement d’entrée utilisateur. Il peut s’agir :
\begin{itemize}
	\item de l’appui d’une touche
	\item d’un mouvement de souris
	\item de la fermeture d’une fenêtre graphique
	\item etc\dots
\end{itemize}
Il faudrait une structure de donnée capable de stocker toutes les informations relatives à chaque type
d’évènement. On pourrait imaginer la structure suivante :
\begin{minted}[linenos=false]{c}
struct Event {
	struct {
		unsigned x;
		unsigned y;
	} mouse;
	struct {
		int keycode;
		char is_maj_enabled;
		char is_ctrl_enabled;
	} keyboard;
};

...

struct Event e;
some_update_function(&e);
printf("Position souris : (%u, %u)\n", e.mouse.x, e.mouse.y);
\end{minted}
On observe alors que la structure \textsf{mouse} et la structure \textsf{keyboard} ne seront jamais utilisées en même
temps. C’est-à-dire qu’une instance de la structure \textsf{Event} n’``utilisera'' jamais les deux sous-structures
dans un même bloc de code. En effet, cette structure n’est destiné qu’à stocker un seul évènement.
Analysons l’utilisation mémoire de la structure \textsf{Event} :
\begin{itemize}
	\item $4 + 4 = 8$ octets pour stocker la sous-structure \textsf{mouse}
	\item $4 + 1 + 1 = 6$ octets pour stocker la sous-structure \textsf{keyboard}
\end{itemize}
pour un total de $8 + 6 = 14$ octets.

En soi, il suffirait pourtant de seulement 8 octets pour stocker soit la sous-structure \textsf{mouse}, soit la
sous-structure \textsf{keyboard}. C’est à cela que sert l’union.
\subsection{Principe et syntaxe}
L’idée de l’union est assez simple. Alors que la structure agrège les données\footnote{En respectant ou non l’alignement} les unes à la suite des autres en mémoire, l’union les superpose dans le même espace mémoire :

\begin{minipage}{\textwidth}
	\begin{center}
		\includesvg[width=0.25\textwidth]{union}
	\end{center}
\end{minipage}

Ce qui en C s’écrit avec la même syntaxe que pour les structures, en utilisant à la place le mot-clé
\textit{union} :
\begin{minted}[linenos=false]{c}
union Event {
	struct {
		unsigned x;
		unsigned y;
	} mouse;
	struct {
		int keycode;
		char is_maj_enabled;
		char is_ctrl_enabled;
	} keyboard;
};
\end{minted}
Et on observe qu’il s’agit bien du même espace mémoire :
\begin{minted}[linenos=false]{c}
union Event e;
e.mouse.x = 42;
printf("%u\n", e.keyboard.keycode); // prints 42
\end{minted}
Le bénéfice est bien visible au niveau de la taille de la zone mémoire :
\begin{itemize}
	\item 16 octets pour \textsf{struct Event}\footnote{Et pas 14 du fait de l’alignement mémoire, voir la section \ref{sub:alignement}}
	\item 8 octets pour \textsf{union Event}
\end{itemize}
Dans le cas de la programmation de systèmes embarquées ou pour des structures qui seront alloués un
grand nombre de fois en mémoire, le gain de place est non négligeable. Il est ici d’un facteur 2 car il
n’y a que deux évènements. La bibliothèque \textit{Xlib} qui sert d’interface au serveur de fenêtrage X11 de
Linux utilise une union de 33 structures pour stocker les évènements.\footnote{Voir : \url{https://tronche.com/gui/x/xlib/events/structures.html}}
\subsection{Le problème de sélection}
Dans le cas précédent de l'union \textsf{union Event}, il est impossible étant seulement donné l'union de déterminer lequel des deux champs utiliser. On peut imaginer un programme qui renvoie une liste d'évènements pour laquel il serait parfaitement envisageable que chaque évènement utilise un champ différent. Une solution pourrait être de renvoyer autant de listes qu'il y a de type d'évènement différents. Si on a $100$ évènements différents et seulement $2$ évènements réellement utilisés, beaucoup de temps est perdu à vérifier chaque liste vide\footnote{Sans parler des allocations mémoire supplémentaires, l'impossibilité de tout stocker dans un seul tableau et les problèmes de cache qui vont avec.}. Une autre solution consiste à utiliser une énumération pour indiquer par un champ supplémentaire le type de l'évènement :
\begin{minted}[linenos=false]{c}
enum Type {
	T_MOUSE,
	T_KEYBOARD
};
struct Event {
	union {
		struct {
			unsigned x;
			unsigned y;
		};
		struct {
			int keycode;
			char is_maj_enabled;
			char is_ctrl_enabled;
		};
	} e;
	enum Type t;
};
\end{minted}
On peut alors utiliser un aiguillage lors du parcours des évènements sur le champ \textsf{t} pour adapter le code :
\begin{minted}[linenos=false]{c}
for (struct Noeud nd = first(list); not_last(list, nd); nd = next(list, nd)) {
	struct Event event = value(nd);
	switch (event.t) {
		case T_MOUSE:
			// Code pour souris sur :
			event.e.x;
			event.e.y;
			break;
		case T_KEYBOARD:
			// Code pour clavier sur :
			event.e.keycode;
			event.e.is_maj_enabled;
			event.e.is_ctrl_enabled;
			break;
		default:
			// Inconnu
			break;
	}
}
\end{minted}
Utiliser les unions à la place de structures quand cela est possible est une bonne pratique de programmation
à assimiler.
% \subsection{Exercices}
% \exercise{Arbres binaires}Une nouvelle structure de donnée va être abordée dans cet exercice : les arbres binaires. Il s'agit avec les listes chaînées et les tableaux d'une des structures de données les plus élémentaires. Par ailleurs, une immense quantité de structures de données plus complexes ont comme base l'arbre binaire.
\end{document}