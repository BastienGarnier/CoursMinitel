\documentclass[../../../main.tex]{subfiles}
\begin{document}
\textbf{Rappel :} La représentation \textsf{ASCII} est détaillé en table \ref{tab:ascii}
\subsection{Chaîne de caractères}\label{sub:cha_ne_de_caract_res}
Si un caractère est en informatique un mot binaire écrit sur 8 bits, une chaîne de caractères est basiquement un tableau de caractères. On observe toutefois quelques subtilités :
\begin{itemize}
  \item un tableau est de taille finie, et donc doit aussi l'être une chaîne de caractères
  \item une chaîne de caractères ne remplit pas toujours l'entièreté d'un tableau. Il faut donc pouvoir indiquer la fin de la chaîne n'importe où
  \item la structure de donnée du tableau ne permet pas aisément certaines manipulations, comme l'insertion d'une chaîne de caractères au milieu d'une autre
\end{itemize}
\textbf{Remarque :} Concernant le dernier point, aucune solution ne sera proposée ici puisque ce n'est pas le coeur du propos. Il faut se rapprocher d'ouvrages d'algorithmie pour trouver une réponse satisfaisante.\footnote{Cela dépend de plus du besoin. Un \textit{gap buffer} n'aura pas les mêmes propriétés qu'un \textit{rop tree}. C'est bon, j'ai drop quelques noms ça fait genre que je maîtrise ;)}
\subsection{En langage C}\label{sub:en_langage_c}
La manipulation de texte sous forme de chaînes de caractères est native au langage C bien que nettement moins développé que dans d'autres langages.\footnote{Autant dire qu'en C, il n'y a que le strict minimum hein !}
 
En particulier, on peut remarquer que le type du langage C pour des entiers sur 8 bits est \textit{char}, comme \textit{character} qui signifie \textit{caractère} en français.\footnote{Coïncidence ? Je ne crois pas.}
 
La manipulation de caractères et de chaînes de caractères suit une nomenclature précise :
\begin{itemize}
	\item on représente un caractère entre guillements simples : `a', `b', `=', `!', `:', etc\dots
	\item on représente une chaîne de caractères entre guillemets doubles : ``Hello World !'', ``42 is the answer'', etc\dots
\end{itemize}
En langage C :
\begin{minted}[linenos=false]{c}
char chr = '+';
char texte[50] = {'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', ' ', '!', 0};
\end{minted}
\textbf{Remarque 1 :} Comme \textit{char} est un type entier, `+' est le mot binaire associé au caractère +. De même, le tableau de caractères est un tableau de mots binaires représentant chacun des caractères. Il s'ensuit qu'il est équivalent d'écrire :
\begin{minted}[linenos=false]{c}
char chr = 43;
char text[50] = {72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 32, 33, 0};
\end{minted}
On peut ensuite afficher ces caractères par deux ``nouveaux'' modificateurs d'affichage : 
\begin{itemize}
	\item \textsf{char} interprété comme caractère : \textsf{\%c}
	\item \textsf{char[]} ou \textsf{char*} interprétés comme chaînes de caractères : \textsf{\%s}
\end{itemize}
\begin{minted}[linenos=false]{c}
printf("Caractere %c est represente par %d\n", chr, chr);
printf("Premier caractere du texte : %c\n", text[0]);
printf("%s\n", text); // characters array interpreted as text
\end{minted}
Pour celles et ceux qui se posent la question : \textit{``Whatz ve feuck ? Fé koi fe véro à la fin d'une faîne ?}\footnote{Traduction : \textit{Nom de Dieu de putain de bordel de merde de saloperie de connard d’enculé de ta mère\dots Vous voyez, c’est aussi jouissif que de se torcher le cul avec de la soie. J’adore ça. C'est quoi ce zéro à la fin de la chaîne ?}}, le langage C pose par convention que la fin d'une chaîne de caractères est indiqué par le caractère spécial $\setminus0\equiv\textit{[NULL]}$ de valeur entière 0. On peut l'écrire directement dans une chaîne de la façon suivante :
\begin{minted}[linenos=false]{c}
// 0 après le 'l', et 0 en fin de chaîne :
char text[50] = {'H', 'e', 'l', 'l', '\0', ' ', 'W', 'o', 'r', 'l', 'd', ' ', '!', 0};
printf("%s\n", text); // affiche 'Hell' dans la console
\end{minted}
L'affichage s'arrête au premier 0 rencontré qui indique la fin de la chaîne.
 
On peut ensuite modifier cette chaîne de caractères comme un tableau classique :
\begin{minted}[linenos=false]{c}
char text[50] = {'H', 'e', 'l', 'l', '\0', ' ', 'W', 'o', 'r', 'l', 'd', ' ', '!', 0};
text[4] = 'o';
printf("%s\n", text); // Affiche 'Hello World !' dans la console
\end{minted}
\subsection{Se faciliter la vie avec les chaînes littérales}\label{sub:se_faciliter_la_vie_avec_les_cha_nes_litt_rales}
Les lecteurs/rices attentifs/ives auront remarqué un fait étrange. La fonction \textsf{printf} affiche par défaut des chaînes de caractères :
\begin{minted}[linenos=false]{c}
printf("Hello World !");
\end{minted}
et il n'y a pas besoin d'initialiser de p*tain de tableau de c*n pour cela.
 
Cela n'a en fait rien d'étrange\footnote{Étonnant n'est-ce pas ? Qui l'aurait crû ?}, le langage C propose nativement les chaînes de caractères littérales. Il s'agit d'une facilité d'écriture des chaînes de caractères qui consiste simplement à écrire le texte entre guillemets doubles ``'' et laisser le compilateur créer lui-même le tableau en interne, et le remplir avec les caractères précisés entre guillements, plus un 0 pour finir la chaîne.\newline
Ainsi, il est possible d'écrire simplement :
\begin{minted}[linenos=false]{c}
printf("%s", "%s\n"); // 0 est ajouté automatiquement
\end{minted}
Ici, le compilateur construit deux chaînes de caractères : la première qui contient les caractères `\%', `s' et '$\setminus{0}$' et la seconde qui contient les caractères `\%', `s', `$\setminus$n' et '$\setminus0$'. Les caractères `\%' et `s' ne constituent un caractère spécial de formatage que dans la chaîne manipulé par \textsf{printf}, c'est-à-dire la première.
\subsection{Exercices}
\exercise{Calculatrice}{12}Écrire un programme qui demande à l'utilisateur d'entrer des calculs sous la forme $x\star y$, où $x, y\in{\mathbb{R}_{f64}}, \star\in\{+, -, /, *\}$ et lui donne le résultat. Si une erreur a lieu lors de la lecture, le programme termine. Ainsi, un scénario possible d'exécution est le suivant :
\begin{minted}{bash}
user@computer ~/working_directory> gcc calculatrice.c -o main
user@computer ~/working_directory> ./main
> 7 + 5
12.000000
> 8 * 2.2
17.600000
> 0.1 + 0.2
0.300000
> 1. - 0.8
0.200000
> 27.1 / 3
9.033333
> t * 8
Erreur !
user@computer ~/working_directory>
\end{minted}
On rappelle que l'appui des touches \textit{Ctrl + C} permet de forcer l'arrêt du programme. On peut donc exécuter une boucle infinie sans risques.
 
\textbf{Remarque : } $nan\equiv{\textit{Not A Number}}$ et $inf\equiv{\infty}$, que l'on obtenir par $0/0$ et $1/0$. Par ailleurs, ces deux ``nombres'' peuvent être utilisés dans la calculatrice.
 
\textit{\underline{Indication} : un caractère est un nombre, il peut donc être utilisé dans un aiguillage 'switch-case'}

\exercise{AtoI}{15}Écrire une fonction \textsf{int atoi(char* string);} qui prend en entrée une chaîne de caractères représentant un nombre. Le signe doit être pris en considération. Si la chaîne contient des espaces, ils doivent être ignorés. Le programme ignore tout ce qui suit la première lettre rencontrée.\newline
Si l'entrée n'est pas valide, le comportement est indéterminé (\textit{i.e.} laissé au choix du programmeur).

Exemples de sortie :
\begin{itemize}
	\item ``42'' : $42$
	\item ``-53'' : $-53$
	\item `` +74TEXTE'' : $+74$
\end{itemize}
\textit{\underline{Note :} Aucune routine de la bibliothèque standard ne doit être utilisée dans \textsf{atoi} !!!\footnote{Trop facile sinon\dots}}
\end{document}