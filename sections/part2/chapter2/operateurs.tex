\documentclass[../../../main.tex]{subfiles}
\graphicspath{{sections/part2/images/}}
\begin{document}
\definition{Opérateurs et opérandes}{Les opérateurs sont des fonctions d'arité strictement positive. Les opérandes sont les ``termes'' des opérateurs, c'est-à-dire les entités sur lesquels les opérateurs effectuent leur opération.}

Il existe quatre familles principales d'opérateurs sur les variables en C :
\begin{itemize}
	\item les opérateurs arithmétiques
	\item les opérateurs bit-à-bit
	\item les opérateurs logiques/relationnels
	\item les opérateurs d'assignation
\end{itemize}
La syntaxe générale des opérateurs sur les variables est la suivante (selon l'arité de l'opérateur) :
\begin{minted}[linenos=false]{c}
TYPE v1 = VALEUR1;
TYPE v2 = VALEUR2;

// opérateur unaire :
<OPERATION> v1; // le résultat n'est pas stocké

// opérateur binaire :
v1 <OPERATION> v2; // le résultat n'est pas stocké
\end{minted}
Par ailleurs, certains opérateurs sont prioritaires sur d'autres. Pour forcer une opération à être évaluée avant une autre, il est possible de parenthéser les expressions :
\begin{minted}[linenos=false]{c}
TYPE v1 = VALEUR1;
TYPE v2 = VALEUR2;

TYPE v3 = (v2 <OP2> (v1 <OP1> v2)); // l'opérateur OP1 est calculé avant OP2
\end{minted}
Par ailleurs, le langage organise les opérations selon une priorité par défaut. Si on écrit :
\begin{minted}[linenos=false]{c}
TYPE v3 = v2 <OP2> v1 <OP1> v2;
\end{minted}
, alors dans le cas où \textsf{$<$OP1$>$} est prioritaire sur \textsf{$<$OP2$>$}, il n'y a pas modification par rapport à l'expression parenthésée ci-dessus. Dans le cas où \textsf{$<$OP2$>$} est prioritaire sur \textsf{$<$OP1$>$}, cela diffère.
 
Pour tous les opérateurs présentés dans la suite, on pourra se référer à la table de priorités suivante\footnote{Copiée de \url{https://en.cppreference.com/w/c/language/operator_precedence} parce-que sur ce genre de chose, inutile d'être original.} :
\begin{center}
\begin{tabular}{|c|p{0.15\textwidth}|p{0.5\textwidth}|l|}
\hline
Priorité & Opérateur & Description & Associativité \\
\hline
1 & ++ -- \newline () \newline [] \newline . \newline $\rightarrow$ \newline (type)\{list\} & Incrémentation et décrémentation postfixes \newline Appel de fonction \newline Indexation de tableau \newline Accès à un membre de structure \newline Accès à un membre de structure par un pointeur \newline Construction de littéral & Gauche à droite\\
\hline
2 & ++ -- \newline + - \newline ! \~ \newline (type)object \newline * \newline \& \newline sizeof \newline \_Alignof & Incrémentation et décrémentation préfixes \newline Signes \newline Non logique et bit à bit \newline Projection de type \newline Indirection \newline Récupération de l'adresse \newline Récupération de la taille \newline Alignement & Droite à gauche \\
\hline
3 & * / \% & Multiplication, division et modulo & Gauche à droite \\
\hline
4 & + - & Addition et soustraction & Gauche à droite \\
\hline
5 & $<<$ $>>$ & Fonctions $\ll$ et $\gg$ & Gauche à droite \\
\hline
6 & $<$ $<=$ \newline $>$ $>=$ & Relations $<$ et $\leq$ \newline Relations $>$ et $\geq$ & Gauche à droite \\
\hline
7 & $==$ $!=$ & Opérateurs relationnels d'égalité et de différence & Gauche à droite \\
\hline
8 & \& & ET bit-à-bit & Gauche à droite \\
\hline
9 & $\wedge$ & OU exclusif bit-à-bit & Gauche à droite \\
\hline
10 & $|$ & OU inclusif bit-à-bit & Gauche à droite \\
\hline
11 & \&\& & ET logique & Gauche à droite \\
\hline
12 & $||$ & OU logique & Gauche à droite \\
\hline
13 & ?: & Condition ternaire & Droite à gauche \\
\hline
14 & $=$ \newline += -= \newline *= /= \%= \newline $<<$= $>>$= \&= $\wedge$= $|$= & Opérateur d'assignement simple \newline Assignement par somme et différence \newline Assignement par produit, quotient et reste \newline Assignement par décalages bit-à-bit gauche ou droit \newline Assignement par OU inclusif, OU exclusif, ET bit-à-bit & Droite à gauche\\
\hline
15 & , & Virgule & Gauche à droite\\
\hline
\end{tabular}
\captionof{table}{Priorités des opérateurs en C}
\end{center}
La priorité indique l'ordre de consommation des opérandes. Ainsi, un opérateur de priorité 1 effectuera son calcul sur ses opérandes avant les opérateurs de priorité 2, 3, etc\dots
\subsection{Opérateurs arithmétiques}
On liste les opérateurs arithmétiques suivants :
\begin{center}
\begin{tabular}{l|c|c|c}
Opération & Arité & Symbole mathématique & Symbole en C \\
\hline
Addition & 2 & $+$ & $+$ \\
Soustraction & 2 & $-$ & $-$ \\
Multiplication & 2 & $\times$ & $*$ \\
Division entière & 2 & $\div$ & $/$ \\
Modulo & 2 & $\%$ & $\%$
\end{tabular}
\captionof{table}{Opérateurs arithmétiques}
\end{center}
Ces opérateurs sont les plus communs du langage avec les opérateurs logiques. Ils permettent en particulier de modifier les variables assignés en effectuant des calculs.
\begin{minted}{c}
#include <stdio.h>
#include <stdlib.h>

int main() {
	int a = 18;
	int b = 67;
	printf("a = %d; b = %d\n", a, b);
	printf("a + b = %d\n");
	printf("a - b = %d\n");
	printf("a * b = %d\n");
	printf("a / b = %d\n");
	printf("b / a = %d\n");

	return EXIT_SUCCESS;
}
\end{minted}
On observe que la division est bien entière en posant les divisions euclidiennes :
\begin{itemize}
	\item $\left\lfloor{\dfrac{18}{67}}\right\rfloor = 0$ car $18 = 67\times{\textbf{0}} + 18$
	\item $\left\lfloor{\dfrac{67}{18}}\right\rfloor = 3$ car $67 = 18\times{\textbf{3}} + 13$
\end{itemize}
% \textbf{Priorité des opérateurs arithmétiques :}
%  
% Bien que le parenthésage puisse permettre de forcer les priorités, le langage C impose par défaut une certaine priorité aux opérations :
% \begin{itemize}
% 	\item la multiplication, la division et le modulo sont de même priorité supérieure à celle de l'addition et de la soustraction et sont donc évaluées d'abord
% 	\item l'addition et la soustraction sont de même priorité inférieure à celle de la multiplication, de la division et du modulo et sont donc évaluées ensuite
% \end{itemize}

\subsection{Opérateurs bit-à-bit}
On liste les opérateurs bit-à-bit suivants :
\begin{center}
\begin{tabular}{l|c|c|c}
Opération & Arité & Symbole mathématique & Symbole en C \\
\hline
ET & 2 & $\wedge$ & $\&$ \\
OU inclusif & 2 & $\vee$ & $|$ \\
OU exclusif & 2 & $\oplus$ & $\wedge$ \\
NON & 1 & $\neg$ & $\sim$ \\
Décalage à droite signé (ou arithmétique) & 2 & $\gg_{a}$ & $>>$ \\
Décalage à droite non signé (ou logique) & 2 & $\gg_{l}$ & $>>$ \\
Décalage à gauche & 2 & $\ll$ & $<<$
\end{tabular}
\captionof{table}{Opérateurs bit-à-bit}
\end{center}
Ces opérateurs sont décrits en détails dans la partie 1 du cours.
\subsection{Opérateurs logiques, ou relationnels}
\definition{Vérité d'une expression}{On dit qu'une expression est \textit{fausse} si sa valeur est égale à 0. On dit qu'elle est \textit{vraie} sinon.}
 
Les opérateurs logiques, contrairement aux opérateurs bit-à-bits, ne travaillent pas sur les valeurs de variables mais sur leur valeur de vérité. En particulier, ils ne renvoient que 1 ou 0, c'est-à-dire \textit{vrai} ou \textit{faux}.
 
On liste les opérateurs logiques suivants :
\begin{center}
\begin{tabular}{l|c|c|c}
Opération & Arité & Symbole mathématique & Symbole en C \\
\hline
Égalité & 2 & $=$ & $==$ \\
Différence & 2 & $\neq$ & $!=$ \\
ET logique & 2 & $\wedge$ & $\&\&$ \\
OU logique & 2 & $\vee$ & $||$ \\
NON & 1 & $\neg$ & $!$
\end{tabular}
\captionof{table}{Opérateurs logiques}
\end{center}
\textbf{Remarque :} Il s'agit d'un OU \textit{inclusif}. Le OU exlusif n'a pas de version ``logique'' en C.
 
Quelques exemples :
\begin{minted}[frame=single]{c}
int a = 5;
int b = 7;
printf("%d\n", !(b-a)); // b-a = 2 est vrai donc !(b-a) est faux -> 0
printf("%d\n", !!(a + b)); // -> !0 = 1
printf("%d\n", a != b); // -> 1
printf("%d\n" a == b); // -> 0
printf("%d\n", !!(a+b) == (a != b)); // -> 1
printf("%d\n", a != b && a == b); // -> 0
printf("%d\n", a == b || (a + b)); // -> 1
printf("%d\n", a-b && (a != b)); // -> 1 car les deux propositions sont vraies
\end{minted}
\textbf{Remarque :} On observe que pour tout entiers $a$ et $b$, $a-b\equiv a \neq b$. En effet, $a \neq b \Leftrightarrow a - b \neq{0}$
\subsection{Opérateurs d'assignation}
Les opérateurs d'assignation sont à la fois les éléments les plus connus par les débutants et à la fois les opérateurs dont ces mêmes débutants ignorent tout des spécificités. Voici un exemple qui pourrait surprendre :
\begin{minted}{c}
#include <stdio.h>
#include <stdlib.h>

int main() {
	int a;
	printf("Initialement, a = %d\n", a = 0);
	printf("Puis a = %d\n", ++a);
	printf("Et enfin, a = %d\n", a <<= 3);
	return EXIT_SUCCESS;
}
\end{minted}
Les différentes opérations présentent dans ce code sont expliqués dans la suite\footnote{Bien qu'une exécution et quelques tests accompagnés d'un peu d'intuition pourraient suffire à comprendre}.
 
\subsubsection{Opérateur élémentaire d'assignation $=$}
 
L'opérateur binaire $=$, dit d'assignation, n'effectue pas que l'assignation d'une valeur à une variable. Il renvoie également la valeur assignée.\newline
Ainsi, l'opération $a = 2$ est égale à 2. On peut donc écrire de manière équivalente :

\begin{minipage}{0.5\textwidth}
\begin{minted}[linenos=false]{c}
int a;
int b = (a = 3) + 1;
\end{minted}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\begin{minted}[linenos=false]{c}
int a = 3;
int b = a + 1;
\end{minted}
\end{minipage}

En particulier, il est possible d'initialiser plusieurs variables à une même valeur par le code suivant, tout à fait illisible :
\begin{minted}{c}
#include <stdio.h>
#include <stdlib.h>

int main() {
	int a, b, c, d, e = (d = (c = (b = (a = 3))));
	printf("a : %d, b = %d, c = %d, d = %d, e = %d\n", a, b, c, d, e);
	return EXIT_SUCCESS;
}
\end{minted}
Il n'est pas particulièrement utile d'utiliser cette particularité de l'opérateur d'assignation sauf dans des cas très spécifiques. Mais c'est toujours bon à savoir lorsqu'on tombe sur le code d'un tiers qui l'utilise.
 
\subsubsection{Combinaison de l'opérateur d'assignation et des opérateurs binaires de calcul}
 
Les opérateurs binaires arithmétiques et bit-à-bits peuvent être combinés avec l'opérateur d'assignation pour contracter le code :
\begin{minted}[linenos=false]{c}
int a = ...; // valeur quelconque
a += 3; // a = a + 3
a -= 3; // a = a - 3
a *= 3; // a = a * 3
a /= 3; // a = a / 3
a %= 3; // a = a % 3
a |= 3; // a = a | 3
a &= 3; // a = a & 3
a ^= 3; // a = a ^ 3
a <<= 3; // a = a << 3
a >>= 3; // a = a >> 3
\end{minted}
L'équivalence à l'expression en commentaire est totale. Ainsi, ces combinaisons renvoient la nouvelle valeur de $a$.
 
\subsubsection{Incrémentation et décrémentation}
 
En raison de présence extraordinairement récurrente des deux opérations d'incrémentation et de décrémentation (c'est-à-dire l'ajout de 1 à la valeur d'une variable, ou sa diminution de 1), deux opérateurs spécifiques existent pour performer de manière optimisé ces opérations :
\begin{itemize}
	\item \textsf{++variable;}\footnote{Ce qui a d'ailleurs amené au nommage du langage \textit{C++} comme une version ``incrémentée'', étendue, du langage C}
	\item \textsf{--variable;}
\end{itemize}
Il y a équivalence entre les expressions suivantes :
 
\begin{minipage}{0.5\textwidth}
\begin{minted}[linenos=false]{c}
int a = 0;
a += 1;
a -= 1;
\end{minted}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\begin{minted}[linenos=false]{c}
int a = 0;
++a; // renvoie 1
--a; // renvoie 0
\end{minted}
\end{minipage}

Ainsi, $++a$ renvoie la valeur de $a$ \textit{après} incrémentation et $--a$ renvoie la valeur de $a$ \textit{après} décrémentation.
 
Toutefois, la forme la plus connue de l'incrémentation et de la décrémentation est la suivante :
\begin{minted}[linenos=false]{c}
int a = 0;
a++; // renvoie 0
a--; // renvoie 1
a; // renvoie 0
\end{minted}
Dans ce cas, la valeur renvoyée est celle \textit{avant} l'incrémentation ou la décrémentation. Ce qui explique le décalage par rapport au code juste ci-dessus.
 
\textbf{Remarque :} Chaque opération d'assignation renvoie une valeur numérique, et non une variable. Ainsi, chacune des lignes du code suivant provoque une erreur car n'a aucun sens :
\begin{minted}[linenos=false]{c}
(a = N)++;
(a++) = N;
a += 2 += 2;
a = b = 3;
\end{minted}
\subsection{Exercices}
Voir \cite{BitHacks} pour approfondir les calculs binaires optimisés.

\exercise{Valeur}{08}
Quelle est la valeur de $i$ après la suite d'instructions :
\begin{minted}[linenos=false]{c}
int i = 10;
i = i - (i--);
\end{minted}
Quelle est la valeur de $i$ après la suite d'instructions :
\begin{minted}[linenos=false]{c}
int i = 10;
i = i - (--i);
\end{minted}
\exercise{Calcul d'expressions}{10}\newline
Évaluer à la main les valeurs de $a$, $b$, $c$ et $d$ écrites en langage C :
\begin{minted}[linenos=false]{c}
int a = 57 + (4 - 6);
int b = a - 2 * 7;
int c = b / 3 * 4 + b;
unsigned short int d = c - (100 % c + 100);
\end{minted}
\exercise{Priorité des opérateurs}{11}
Enlever les parenthèses des expressions suivantes lorsqu'elles peuvent être retirées (c'est-à-dire que le résultat du programme reste le même) :
\begin{minted}[linenos=false]{c}
int a = 6, b = 12, c = 24;
a = (25*12) + b;
printf("%d", ((a > 4) && (b == 18)));
((a >= 6)&&(b < 18)) || (c != 18);
c = (a = (b + 10));
\end{minted}
\exercise{Interversion sans effet de bord (1)}{15} Écrire un programme en C qui initialise deux variables $a$ et $b$ de valeurs différentes. \textit{Sans initialiser une seule variable supplémentaire}, échanger les mots binaires des deux variables. Ainsi, si $a = a_{N_{a}-1}\dots{a_{0}}$ et $b = b_{N_{b}-1}\dots{b_{0}}$ à leurs initialisations, alors en fin d'exécution il faut avoir $b = a_{N_{a}-1}\dots{a_{0}}$ et $a = b_{N_{b}-1}\dots{b_{0}}$ sans que les assignations soient explicites. C'est-à-dire que le code ne doit pas à être modifié si les valeurs de $a$ et $b$ sont changées.\newline
Justifier que ce programme est toujours correct pour des entiers codés chacun sur $N$ bits, quelques soient les signatures de $a$ et $b$. Ce programme est-il toujours correct si $a$ et $b$ ne sont pas écrits sur autant de bits ? Justifier.
 
\exercise{Interversion sans effet de bord (2)}{15} \textit{idem} que pour l'\refexercise{Interversion sans effet de bord (1)} mais l'unique opérateur autorisé est l'opérateur de OU exclusif (noté $\wedge$ en C).
 
\exercise{Multiplication par décalage}{12}\newline
On remarque que pour entiers $n, m\in{\mathbb{N}}$, $n\ll{m} = n\times2^{m}$. En utilisant uniquement des additions ou soustractions de décalages, effectuer la multiplication $57\times{14}$ :
\begin{minted}{c}
#include <stdio.h>
#include <stdlib.h>

int main() {
	int a = 57;
	int r;
	// ici : code à déterminer
	printf("57x14 = %d", r);
	return EXIT_SUCCESS;
}
\end{minted}
Minimiser le nombre de décalages et d'additions/soustractions (objectif : 2 décalages et une addition ou soustraction)
 
\exercise{Valeur absolue}{14}En utilisant uniquement des opérations arithmétiques et bit-à-bits, écrire un programme qui calcule la valeur absolue d'un entier signé :
\begin{minted}{c}
#include <stdio.h>
#include <stdlib.h>

int main() {
	int x = ...; // valeur quelconque, positive comme négative
	unsigned int abs_x;
	// ici : code à déterminer
	printf("|%d| = %u", x, abs_x);
	return EXIT_SUCCESS;
}
\end{minted}
\end{document}