\documentclass[../../../main.tex]{subfiles}
\begin{document}
\subsection{Tableaux}
\label{sub:tableaux}
\definition{Structure de donnée}{Une structure de donnée est une manière de stocker les données. Il s'agit de la collection d'un ensemble de valeurs, de relations entre ces valeurs et de fonctions/d'opérations qui peuvent être appliquées à ces valeurs. Une structure de donnée peut être comparée ainsi à une structure algébrique en mathématiques.}
 
Le \textit{tableau} est une des structures de donnée les plus simples. Il s'agit de l'équivalent informatique des $N$-uplets en mathématiques. Un tableau permet de stocker plusieurs variables sous une même étiquette de manière contigüe en mémoire : 

\begin{minipage}{\textwidth}
	\begin{center}
		\includesvg[width=.25\textwidth]{array}
	\end{center}
\end{minipage} 

Un tableau est dit \textit{indicé}, c'est-à-dire que tous ses éléments sont numérotés, dans l'ordre, à partir de 0 :
\begin{itemize}
	\item élément 1 : indice 0
	\item élément 2 : indice 1
	\item \dots
	\item élément $N$ : indice $N - 1$
\end{itemize}
Si on considère que chaque élément est codé sur $t$ bits, et que le premier élément est à l'adresse mémoire $a_{0}$, alors le $i^e$ élément est situé à l'adresse $a_{i} = a_{0} + (i - 1)t$. En particulier, vouloir accéder au $N^e$ et dernier élément du tableau par l'adresse $a_{0} + Nt$ provoque une erreur, car cette adresse mémoire est située hors du tableau et est potentiellement interdite d'accès.
 
\begin{minipage}{\textwidth}
	\begin{center}
		\includesvg[width=.4\textwidth]{array2}
	\end{center}
\end{minipage}
 
En langage C, il existe deux manières principales d'\textit{implanter} un tableau :
\begin{itemize}
	\item Par allocation statique : allocation par le compilateur d'un tableau de taille fixé avant l'exécution du programme sur la pile d'exécution\footnote{Le plus souvent. Cela dépend de la \textit{classe de stockage} utilisé, voir le chapitre correspondant.} (voir \textbf{4.6.3} pour un rappel)
	\item Par allocation dynamique : allocation par le programmeur un tableau dont la taille dépend d'une variable du programme, sur le tas
\end{itemize}
Cette section ne décrit que l'allocation statique.
\subsection{Définition}
\label{sub:d_finition}
L'allocation sur la pile, dite statique, est effectuée en langage C par la syntaxe suivante :
\begin{minted}[linenos=false]{c}
TYPE array[SIZE]; // tableau non initialisé
TYPE array[SIZE] = {v1, v2, ..., vSIZE}; // tableau initialisé
\end{minted}
On appelle \textit{statique} ce type d'allocation de mémoire car $SIZE$ \underline{ne peut être une variable !} Ainsi, il est incorrect d'écrire :
\begin{minted}[linenos=false]{c}
int n = 5;
int array[n]; // incorrect
\end{minted}
Cette syntaxe provoque une erreur de compilation pour tous les compilateurs conformes aux normes du langage C avant la version C99. 
En effet, la taille d'un tableau statique doit pouvoir être déterminé par le compilateur au moment de la compilation. Celui-ci peut ainsi produire des instructions machines pour stocker ce tableau sur la pile d'exécution comme $n$ variables de tailles déterminées.

Certaines versions de certains compilateurs plus récents peuvent cependant accepter cette syntaxe et remplacer le code par une \textit{allocation dynamique} (voir section suivante \ref{sec:allocation_dynamique}). Pour des raisons de compatibilité et pour éviter certains bugs, il est expressément recommandé d'éviter cette pratique douteuse.
 
Il est par contre tout à fait possible de préciser la taille d'un tableau par un symbole définie par une directive pré-processeur :
\begin{minted}[linenos=false]{c}
#define N 5
int array[N]; // à la compilation, chaque N sera remplacé par le symbole 5 dans le code
\end{minted}
Voyons simplement quelques exemples pour se familiariser avec la notation :
\begin{minted}[linenos=false]{c}
unsigned int chiffres[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
char just_a_zero[1] = {0};
short int numbers[4] = {-78, 52, 17, -10};
\end{minted}
On rappelle que les tableaux sont indicés de 0 à $(TAILLE - 1)$. On accède à un élément d'un tableau par la syntaxe suivante :
\begin{minted}[linenos=false]{c}
array[index];
\end{minted}
Ainsi, le code suivant ajoute 1 à tous les éléments d'un tableau de taille 50 :
\begin{minted}[linenos=false]{c}
#define N 50
int main() {
	int array[N] = {...}; // valeurs quelconques
	for (int i = 0; i < N; i++) {
		array[i]++;
	}
}
\end{minted}
\textbf{Remarque 1 :} tenter d'accéder au tableau par un indice supérieur ou égal à sa longueur provoque souvent une erreur. En effet, il n'est pas certain que la case juste hors du tableau ne soit pas utilisée par un autre programme de l'ordinateur et ne soit donc pas autorisée d'accès pour le programme.
 
\textbf{Remarque 2 :} La syntaxe permettant d'initialiser \textit{toutes} les valeurs d'un tableau n'est valide qu'à sa déclaration. Il n'est ensuite possible de modifier les valeurs du tableau que \textit{une à une} !!!  

\begin{minipage}{0.75\textwidth}
\begin{minted}[linenos=false]{c}
long int array[7]; // déclaration non initialisée

 // ERREUR :
array = {3141526535, 0xBEEF, 747, 0xC4, 713705, 666, 1414};

// ERREUR à nouveau :
array[7] = {3141526535, 0xBEEF, 747, 0xC4, 713705, 666, 1414}; 

// Python n'est pas C :
array = [i for i in range(7)]; // ERREUR !!!
\end{minted}
\end{minipage}
\begin{minipage}{0.25\textwidth}
\begin{minted}[linenos=false]{c}
long int array[7];

// pas d'erreurs :
array[0] = 3141526535;
array[1] = 0xBEEF;
array[2] = 747;
array[3] = 0xC4;
array[4] = 713705;
array[5] = 666;
array[6] = 1414;
\end{minted}
\end{minipage}
La raison, qui \og expliquera \fg au passage l'utilisation des accolades $\{\dots\}$ sera vue dans la section \ref{sec:construction_de_litt_raux} sur la construction de littéraux dans le chapitre \ref{chap:concepts_avances} sur les concepts avancés du langage.
\subsection{Les tableaux statiques, kékoi pour de vrai ?}
\label{sub:les_tableaux_statiques_k_koi_pour_de_vrai_}
Les tableaux statiques sont à un certain point de vue très proches comportementalement des pointeurs. Ils en diffèrent pourtant du tout au tout.
 
Pour mieux comprendre la nature d'un tableau, il faut exécuter le code suivant :
\begin{minted}{c}
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char **argv) {
	int array[3] = {1, 2, 3};

	printf("array = %p | &array = %p | &(array[0]) %p\n", array, &array, &(array[0]));

	return EXIT_SUCCESS;
}
\end{minted}
Le résultat est assez surprenant, puisqu'on observe l'égalité des trois formules. Cela semble tout à fait étrange. En particulier, \textsf{tab} semble être égal à son premier élément, puisque \textsf{\&(tab[0]) == \&tab}, mais puisque \textsf{tab == \&tab}, cela ne peut pas être le cas, puisqu'alors on aurait alors un premier élément toujours égal à l'adresse de \textsf{tab}.
 
Cette étrangeté tient en une phrase, d'apparence barbare : \textbf{les tableaux, en C, ne sont pas des entités de première classe}\footnote{Voir \url{https://www.gnu.org/software/c-intro-and-ref/manual/html_node/Limitations-of-C-Arrays.html} ainsi que \url{https://en.wikipedia.org/wiki/First-class_citizen}}. On appelle, en programmation, une entité de première classe une entité informatique régit par les mêmes règles générales que les autres entités fondamentales du langage. Il peut s'agir par exemple de pouvoir :
\begin{itemize}
	\item être créé à l'exécution du programme
	\item être renvoyé par une fonction
	\item être assigné à une variable
	\item être passé en argument à une fonction
\end{itemize} 
Il est absolument fondamentale de comprendre les conséquences de cette affirmation : les tableaux statiques ne sont pas régis par les mêmes règles que les autres entités plus génériques du langage C. En particulier, il n'est pas possible de manipuler un tableau comme un \textit{tout} de la même manière qu'une variable ``classique''. En particulier, un tableau suit la règle suivante :
 
\textbf{Règle de la conversion :\footnote{L'appelation n'a rien d'officiel, mais je trouvais qu'elle décrivait bien l'état de fait.}}
 
Tout identifiant référant à un tableau dans un code C subit une conversion comme pointeur vers l'adresse du premier élément du tableau. Aux exceptions suivantes :
\begin{itemize}
	\item l'opérateur $\&$ renvoie l'adresse du tableau au sens d'entité, pas l'adresse du tableau au sens de la première case de celui-ci. Ainsi, $*(\&array)$ est égal à $array$, c'est-à-dire à l'adresse de la première case. Pour autant, on a tout de même \textsf{\&array == array} car l'entité tableau se situe en mémoire au même endroit que les valeurs du tableau.\footnote{Si ça vous paraît tordu\dots À moi aussi pour être honnête.}
	\item les opérateurs \textsf{sizeof}, \textsf{typeof} et \textsf{\_Alignof} ne convertissent pas l'identifiant en pointeur mais travaillent uniquement sur le type du tableau, puisque cela est suffisant.
\end{itemize}
Cette règle amène à plusieurs propriétés.
\subsubsection{Accès aux éléments par incrémentation du pointeur}
\label{ssub:acc_s_aux_l_ments_par_incr_mentation_du_pointeur}
En considérant la déclaration d'un tableau quelconque :
\begin{minted}[linenos=false]{c}
TYPE array[N] = {...};
\end{minted}
L'égalité suivante est vraie pour tout indice positif strictement inférieur à $N$ :
\begin{minted}[linenos=false]{c}
array[indice] == *(array + index);
\end{minted}
En effet, \textsf{tab} est ici interprété comme un pointeur \textsf{TYPE*} vers la première case. Il est donc possible d'accéder aux cases du tableau comme pour un pointeur. En fait, il faut plutôt penser à cela dans le sens inverse : l'opération a été définie sur les pointeurs, et on retrouve cette facilité d'écriture pour manipuler les tableaux.
 
\textbf{Remarque :} L'addition est une opération commutative\dots donc le code suivant est tout à fait correct :
\begin{minted}[linenos=false]{c}
index[array] == array[index]; // == *(array + index)
\end{minted}
Ainsi, le code suivant est correct :
\begin{minted}{c}
#include <stdio.h>
#include <stdlib.h>

int main() {
	int some_array[10];
	for (unsigned int i = 0; i < 10; i++) {
		i[some_array] = i;
		printf("%d;", some_array[i]);
	}
	printf("\b \n");
	return EXIT_SUCCESS;
}
\end{minted}
La notation n'est pas utilisée car assez illisible.\footnote{Question d'habitude\dots}
\subsubsection{Passage d'un tableau en argument à une routine}
\label{ssub:passage_d_un_tableau_en_argument_une_routine}
Le langage C autorise à passer un tableau en argument à une routine (voir \refexercise{Routines classiques de manipulation de tableaux}). Mais cela cache en vérité une subtilité : ce n'est pas un tableau qui est passé en argument, mais un pointeur vers le tableau !\newline
Un exemple :
\begin{minted}{c}
#include <stdio.h>
#include <stdlib.h>

void procedure(int array[]) { // donne l'impression d'être un tableau
	printf("%ld", sizeof(array));
}

int main() {
	int test[5] = {1, 2, 3, 4, 5};
	
	printf("%ld", sizeof(test)); // -> sizeof(int) * 5 = 20
	procedure(test); // -> sizeof(int*) = 8

	return EXIT_SUCCESS;
}
\end{minted}
\textsf{sizeof} renvoie la taille mémoire calculée à la compilation. Ainsi, dans la fonction \textsf{main}, \textsf{sizeof(test)} est calculable car le compilateur fait le lien avec le tableau de cinq éléments définit précédemment, de type \textsf{int}.
 
Par contre, l'appel à \textsf{procedure} utilise une référence à un tableau, qui est donc interprétée comme un pointeur vers la première case. \textsf{procedure} recevra donc toujours un pointeur vers le premier élément du tableau. Un pointeur est stocké sur huit octets.
 
Par ailleurs, cela signifie également que le tableau n'est pas copié en mémoire au passage en argument, et que les modifications d'un tableau dans une routine sont permanents :
\begin{minted}{c}
#include <stdio.h>
#include <stdlib.h>

void incr_all(int array[], unsigned int length) {
	for (int i = 0; i < length; i++) {
		array[i]++;
	}
}

int main() {
	int test[5] = {1, 2, 3, 4, 5};
	
	incr_all(test, 5);
	incr_all(test, 5);

	printf("%d = %d\n", test[2], *(test + 2)); 

	return EXIT_SUCCESS;
}
\end{minted}
L'incrémentation de tous les éléments du tableau est permanente et subsiste dans la suite du programme. Cela est logique, puisque c'est un pointeur vers les éléments du tableau qui est donné à la procédure.
\subsubsection{Renvoi d'un tableau par une fonction}
\label{ssub:renvoi_d_un_tableau_par_une_fonction}
Il a déjà été dit qu'un tableau ne pouvait être renvoyé par une fonction. Cependant, un pointeur peut l'être. Une première intuition serait donc de créer un tableau dans la fonction, puis de renvoyer un pointeur vers celui-ci :
\begin{minted}{c}
#include <stdio.h>
#include <stdlib.h>

char *test_function() {
	char test_array[10] = {3, 1, 4, 1, 5, 9, 2, 6, 5, 4};
	return test_array;
}

int main() {
	// Déclaré comme un pointeur car test_function renvoie un pointeur :
	char *ret_array = test_function();
	
	/* la ligne suivante produit une erreur À LA COMPILATION :
	char ret_array[10] = test_function();
	*/
	
	printf("Premier element (?) : %d\n", *ret_array);
	return EXIT_SUCCESS;
}
\end{minted}
Aucune erreur de compilation à signaler, mais à l'exécution\dots patatras. Le classique code $-11$ d'erreur de segmentation apparaît sur la console, dans l'incompréhension la plus totale\dots
 
Il faut se rappeler d'un point technique pour comprendre l'erreur ici : les variables initialisés statiquement, dont l'allocation en mémoire est effectuée par le compilateur, sont libérées par le compilateur à la sortie de la routine !\footnote{C'est-à-dire que la région de la pile utilisée pour l'environnement local de la fonction est vidée pour laisser la place à d'autres environnements locaux d'autres fonctions.}
 
Le tableau déclaré et initialisé dans \textsf{fonction\_test} a été libéré dès la sortie de la fonction. L'accès mémoire à son adresse est donc interdit par le système d'exploitation puisque cette zone mémoire n'est plus ``fournie'' au programme.
 
Une solution ? Oui, avec les tableaux dynamiques !\footnote{Pour celles et ceux qui se demandent : oui, il y a une suite à cette phrase, mais ceci est une autre histoire\dots}
\subsection{Exercices}
\exercise{Les routines, direction la seconde classe !}{05} Justifier que les routines en C ne sont pas non plus des entités de première classe.

\exercise{Routines classiques de manipulation de tableaux}{20}
Soit $T$ un tableau de $l(T)\in\mathbb{N}$ éléments. On note pour $i, j\in{\llbracket 0; l(T)-1}\rrbracket$ :
\begin{itemize}
	\item $T[i]$ : l'élément de $T$ d'indice $i$
	\item $T[i:j]$ : le sous-tableau de $T$ d'adresse $T + i$ et de $l(T[i:j]) = j - i$ éléments, c'est-à-dire que $T[0:l(T)] = T$.
	\item Pour $k\in\llbracket 0; l(T[i:j]) - 1 \rrbracket$, on a donc $T[i:j][k] = T[i + k]$
\end{itemize}
\begin{enumerate}
	\item écrire une fonction \textsf{int somme(int array[], unsigned int length);} qui renvoie la somme des éléments du tableau.
	\item écrire une procédure \textsf{void display(int array[], unsigned int length);} qui affiche les éléments d'un tableau d'entiers.\newline
		\textit{\underline{Note} : cela pourra être utile pour vérifier le résultat de routines agissant sur des tableaux}
 	\item écrire deux fonctions \textsf{unsigned int max(int array[], unsigned int length);} et \textsf{unsigned int min(int tab[], int taille);} qui renvoient respectivement l'indice du maximum et l'indice du minimum des éléments d'un tableau.
	\item écrire une fonction \textsf{void swap(int array[], int i, int j);} qui échange par la méthode de votre choix les valeurs du tableau d'indices $i$ et $j$.
	\item en utilisant les questions précédentes, écrire une procédure \textsf{void selection\_sort(int array[], unsigned int length);} qui trie dans l'ordre croissant et par effet de bord un tableau $A$ de $n\in\mathbb{N}$ éléments selon l'algorithme ci-dessous.
\begin{algorithm}
\caption{Algorithme de tri de tableau par sélection}\label{alg:select_sort}
\Entree{tableau $A$ et $l(A)$ le nombre d'éléments de $A$}\;
\Sortie{tableau $A$ trié par effet de bord}\;

$i\leftarrow 0$\;
\Tq{$i < l(A)$} {
	Trouver l'indice $i_{min}$ du minimum de $A[i:l(A)]$\;
	Échanger dans $A$ les éléments d'indices $i$ et $i_{min} + i$\;
	$i\leftarrow i+1$\;
}
\end{algorithm}
\item démontrer par récurrence la correction de l'algorithme précédent, c'est-à-dire une démonstration que cet algorithme trie effectivement le tableau dans l'ordre croissant.
\end{enumerate}
\exercise{Recherche dichotomique}{12M} On reprend les notations introduites dans l'\refexercise{Routines classiques de manipulation de tableaux}.
\begin{enumerate}
	\item Soit $T$ un tableau d'entiers trié par ordre croissant. Soit $i\in \llbracket 0; l(T)-1\rrbracket$.Soit $x\in\mathbb{Z}$. Montrer que :
	$$x\in T\Rightarrow \left\{\begin{array}{lcl}
	x\leq T[i] & \Rightarrow & x\in T[0:i] \\
	x> T[i] & \Rightarrow & x\in T[i:l(T)]\end{array}\right.$$
	\item Écrire une fonction \textsf{char is\_in(int x, int array[], unsigned int length);} qui renvoie \textit{Vrai} sur $x$ appartient au tableau $array$ supposé trié dans l'ordre croissant, et \textit{Faux} sinon. Cette fonction devra au pire effectuer $\lceil log_2(length)\rceil$ tours de boucle. On le démontrera grâce à la question 1, en choisissant judicieusement $i$ à chaque tour de boucle.
\end{enumerate}
\exercise{Liste des nombres premiers}{37HM} Cet exercice tient à montrer, dans un exemple particulier, l'importance fondamentale du détail, et comment ce qui semble une infime différence dans la manière d'écrire un code peut changer fondamentalement l'efficacité de l'algorithme mis en oeuvre.
\begin{enumerate}
	\item En programmant une routine du test de primalité de l'\refexercise{Test de primalité}, écrire un programme qui liste les nombres premiers inférieurs à $N$ en au plus $N^{\frac{3}{2}}$ tours de boucles.
	\item En utilisant un tableau de taille $N$ qui stocke les nombres premiers déjà trouvés, utiliser cette fois-ci un test de primalité qui teste si $n\in\mathbb{N}$ est premier en au plus $\pi(\sqrt{n})$ tours de boucle
	\item Programmer l'algorithme du \textit{crible d'Eratosthène} décrit ci-dessous.
	\item Démontrer que l'algorithme de la \textbf{Question 2.} est asymptotiquement plus lent que le crible d'Eratosthène
\end{enumerate}
\begin{algorithm}
\caption{Algorithme du crible d'Eratosthène}
\Entree{$N > 0$ un entier naturel}
\Sortie{les entiers naturels inférieurs à $N$}

Déclarer un tableau $P$ de $N$ booléens\;
Initialiser : $P[0] = Faux$ et $\forall i\in\llbracket 1; N-1\rrbracket, P[i] = Vrai$\;

On pose $p := 2$\;
\Tq{$p^2\leq N$} {
	\Pour{($f := p$ à $\left\lceil \dfrac{N}{p}\right\rceil - 1$)}{
		$P[pf] = Faux$\;
	}
	\Tq{$P[p] = Faux$}{
		$p \leftarrow p + 1$\;
	}
}
\end{algorithm}
\textit{\underline{Note :} On pourra utiliser librement les résultats mathématiques non spécifiques au problème, comme les théorèmes de théorie des nombres ou certains résultats de calcul intégral.
}
\end{document}