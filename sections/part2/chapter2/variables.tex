\documentclass[../../../main.tex]{subfiles}
\graphicspath{{sections/part2/images/}}
\begin{document}
Les variables constituent la brique de base du langage. Une variable au sens informatique est un conteneur d'une donnée dont la valeur peut évoluer au cours de l'exécution du programme.
 
Cette donnée représente de l'information. Elle est donc numérique, bien que l'interprétation puisse être de toute nature : image, vidéo, chaîne de caractère, nombre entier ou à virgule, arbre informatique, etc\dots On peut par exemple penser à la représentation d'une couleur comme un triplet $(r, g, b, a)\in{\llbracket 0, 255\rrbracket^{4}}$, c'est-à-dire un mot binaire de quatre octets, et donc définir une variable de quatre octets qui stocke ces informations.
 
\subsubsection{Rapport entre variable informatique et variable mathématique :}
 
Une variable en mathématique désigne un objet indéterminé. Cela semble au premier abord faux car il peut arriver qu'on écrive les phrases suivantes :
\begin{itemize}
	\item ``Soit $e\in{E}$. \dots'', où $E$ désigne un ensemble quelconque
	\item ``$\forall{x\in{E}}, \mathcal{P}(x)$'', où $E$ désigne un ensemble quelconque et $\mathcal{P}$ un prédicat monadique quelconque
\end{itemize}
En y regardant de plus près, on observe qu'il s'agit en fait simplement de facilités d'écriture équivalentes aux phrases suivantes :
\begin{itemize}
	\item ``Soit $e$ un objet indéterminé. Supposons $e\in{E}$. \dots'', où $E$ désigne un ensemble quelconque
	\item ``$\forall{x}, x\in{E}\implies{\mathcal{P}(e)}$'', où $E$ désigne un ensemble quelconque et $\mathcal{P}$ un prédicat monadique quelconque
\end{itemize}
Cet objet finit par ne plus être indéterminé du fait d'hypothèses à son propos.
 
D'un autre côté, les variables informatiques n'évoluent pas dans le contexte d'une démonstration. Elles sont en fait directement liés au concept physique d'un ordinateur comme des identifiants associées à des adresses mémoire. Elles peuvent donc potentiellement évoluer et changer de valeur au cours du temps. Cette notion de temporalité logique est tout à fait absente du concept de variable mathématique.
 
\subsubsection{Approximation de stockage des variables}
 
On considère dans un premier temps que les variables sont caractérisés par trois informations :
\begin{itemize}
	\item une \textit{étiquette}, aussi appelée le nom de de la variable
	\item une adresse mémoire
	\item une donnée sur $N$ octets (ou $8N$ bits) à cette adresse
\end{itemize}
Une variable peut être vue alors comme une ``case'' de $N$ octets dans la RAM, positionnée à une certaine adresse mémoire. Le langage C nous permet d'associer à cette adresse une étiquette, appelée le nom de la variable. Cette étiquette est oubliée après la compilation, et ne subsiste que l'adresse mémoire dans le programme en langage machine.\newline
Visuellement :

\begin{minipage}{\textwidth}
	\begin{center}
		\includesvg[width=.25\textwidth]{variable}
		\captionof{figure}{Schéma du stockage d'une variable}\label{img:variable}
	\end{center}
\end{minipage}
 
\subsubsection{Type d'une valeur de variable}
\definition{Type}{
Une donnée est une séquence finie de bits (0 ou 1). Il faut interpréter cette donnée pour qu'elle soit utilisable dans un contexte de programmation. L'interprétation de données établit une correspondance entre un ensemble de données\footnote{Donc un ensemble de séquences de 0 et de 1} et un ensemble quelconque d'éléments. Cette correspondance est appelée un \textit{type}. 

On a vu un certain nombre d'interprétations dans le premier chapitre de la première partie ($btoi_{u}$, $btoi_{s}$, norme \textit{IEEE 754} et caractères ASCII).
}
Le langage C propose un certain nombre de types élémentaires directement intégrés au langage. Définir une variable selon un type du langage C consiste à délimiter une séquence de bits en mémoire qui seront mis en correspondance vers un ensemble donné.

Les ensembles mis en correspondances avec ces données en langage C sont des sous-ensembles de $\mathbb{Z}$ ou de $\mathbb{R}$\footnote{Ce qui indique soit une interprétation entière soit une interprétation flottante par la norme \textit{IEEE 754}}. 

Le type permet donc de délimiter les $N$ octets d'un mot binaire et de l'interpréter.
 
Le langage C propose les types de base suivants :
\begin{itemize}
\item Pour représenter des entiers 
\begin{itemize}
	\item \textsf{char} : donnée $d$ sur 1 octet (8 bits) $d\in{\llbracket-128; 127\rrbracket}$
	\item \textsf{short int} : donnée $d$ sur 2 octets (16 bits) $d\in{\llbracket-2^{15}; 2^{15}-1\rrbracket}$
	\item \textsf{int} : donnée $d$ sur 4 octets (32 bits) $d\in{\llbracket-2^{31}; 2^{31}-1\rrbracket}$
	\item \textsf{long int} : donnée $d$ sur 8 octets (64 bits) $d\in{\llbracket-2^{63}; 2^{63}-1\rrbracket}$
\end{itemize}
\item Pour représenter des nombres à virgule :
\begin{itemize}
	\item \textsf{float} : donnée $d$ sur 4 octets (32 bits) $d\in{\mathbb{R}_{f32}}$
	\item \textsf{double} : donnée $d$ sur 8 octets (64 bits) $d\in{\mathbb{R}_{f64}}$
	\item \textsf{long double} : donnée $d$ sur 16 octets (128 bits) $d\in{\mathbb{R}_{f128}}$
\end{itemize}
\item Pour représenter une adresse mémoire : \textsf{TYPE*} : donnée $d$ sur 8 octets contenant l'adresse d'une autre variable de type \textsf{TYPE}
\end{itemize}
La syntaxe du langage C pour déclarer une variable d'un type quelconque \textsf{TYPE} est la suivante :
\begin{minted}[linenos=false]{c}
TYPE any_variable; // variable non initialisée : valeur indéterminée
TYPE any_variable = ANY_VALUE; // initialisée à la valeur ANY_VALUE
\end{minted}
Il n'est pas possible en C de déclarer deux fois un même identifiant. Ainsi, le code suivant provoque une erreur à la compilation :
\begin{minted}[linenos=false]{c}
int age = 20; // déclare age comme un entier de valeur 20
char age = 19; // ERREUR : age déjà déclaré
\end{minted}
Ainsi, un identifiant déclaré avec un certain type ne peut pas en changer jusqu'à ce qu'il ne soit plus définit (c'est-à-dire souvent jusqu'à la fin de l'exécution du programme). Après ne plus être défini, il pourra l'être à nouveau avec un autre type. Cela sera vu avec les \textit{espaces de noms}.
 
\textbf{Remarque 1 :} L'exécution d'un programme en C est séquentielle. Pour cette raison, on ne peut référer à une variable qu'après l'avoir déclarée :
\begin{minted}[linenos=false]{c}
test = 2; // ERREUR : 'test' n'est pas encore déclaré
int test;
\end{minted}
Pour cette raison, toutes les variables doivent être déclarées avant tous les lieux du code où elles se trouvent référencées.
 
\textbf{Remarque 2 :} le symbole \textsf{=} est un symbole d'\textit{assignation}. Contrairement aux conventions mathématiques, il ne définit par une fonction binaire renvoyant $Vrai$ si les deux objets sont égaux. Il permet cependant de changer à tout instant la valeur d'une variable déjà définie :
\begin{minted}[linenos=false]{c}
int nombre_de_feuilles = 2000;
nombre_de_feuilles = 1000; // Assigne à la variable nombre_de_feuilles la valeur 1000
\end{minted}

\begin{minitelbasicbox}{\textbf{Petit apparté} : le type \textsf{char}}
Les caractères ASCII ont été abordés dans la première partie. \textsf{char} signifie \textit{character} en anglais, c'est-à-dire \textit{caractère} en français.

Le langage C propose le même type pour pour faire correspondre le sous-ensemble des entiers $\llbracket-128; 127\rrbracket$ et l'ensemble des caractères ASCII, bien que l'interprétation soit différente. Cela est compréhensible puisque les mots binaires utiles pour ces deux interprétations sont les mêmes, il s'agit cependant d'une petite bizarrerie conceptuelle du langage\footnote{Et ce n'est pas la seule, le C n'ayant peut-être pas été conçu "à l'arrache" mais en tout cas certainement pas de manière super carrée\dots il suffit de voir les tableaux statiques.}. On peut écrire un caractère ASCII grâce aux guillements simples :
\begin{minted}{c}
char carac = 'z';
\end{minted}
ce qui revient strictement à écrire :
\begin{minted}{c}
char carac = 122;
\end{minted}
\end{minitelbasicbox}

On observe une équivalence stricte entre les expressions suivantes : 

\begin{minipage}{0.5\textwidth}
\begin{minted}[linenos=false]{c}
// Première expression :
TYPE variable = valeur;

\end{minted}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\begin{minted}[linenos=false]{c}
// Deuxième expression :
TYPE variable; // valeur indéterminée
variable = valeur;
\end{minted}
\end{minipage}

La première expression est une facilité d'écriture très largement utilisée\footnote{Appelée \textit{sucre syntaxique} dans certains milieux ;-)}
 
En conséquence, le code suivant est tout à fait correct, bien qu'inutile sous cette forme :
\begin{minted}[linenos=false]{c}
int a = a; // La valeur de 'a' est toujours indéterminée
\end{minted}
En effet, le symbole $a$ est définit avant l'assignation.
\subsection{Taille et type d'une variable}
Il est possible de récupérer la taille d'une variable après l'avoir déclarée, ainsi que son type (depuis la version \textit{C23})
 
Cela est effectué par les opérateurs unaires \textsf{sizeof} et \textsf{typeof}. L'opérateur d'alignement \textsf{\_Alignof} sera détaillé dans une section ultérieure.
 
\subsubsection{Opérateur \textsf{sizeof}}
 
L'opérateur \textsf{sizeof} est particulièrement commun. Son exécution est quasiment systématiquement effectuée \textit{à la compilation}. En effet, il retourne une valeur numérique précalculable. La valeur du résultat est donc remplacée dans le code à la génération de l'exécutable.
 
\textsf{sizeof} renvoie le nombre d'octets $N$ nécessaires au stockage de l'espace mémoire associé à une étiquette ou un type. On utilise en général \textsf{sizeof} sur les types :
\begin{minted}[linenos=false]{c}
sizeof(char); // 1
sizeof(short int); // 2
sizeof(int); // 4
sizeof(long int); // 8
sizeof(float); // 4
sizeof(double); // 8
sizeof(long double); // 16

TYPE a;
sizeof(a); // Nombre d'octets pour stocker 'a' en mémoire
sizeof(TYPE); // idem
\end{minted}
\textbf{Remarque :} L'opérateur \textsf{sizeof} renvoie une valeur de type \textsf{size\_t}, équivalente à un \textsf{long int}.

\subsubsection{Opérateur \textsf{typeof}}
L'opérateur \textsf{typeof}, tout comme \textsf{sizeof}, est calculé au moment de la compilation. D'ailleurs, effectuer un tel calcul durant l'exécution du programme n'a aucun sens. En effet, \textsf{typeof} renvoie le type d'une variable. Les deux codes suivants sont donc strictement équivalents : 

\begin{minipage}{0.5\textwidth}
\begin{minted}[linenos=false]{c}
typeof(int) a;
int b;
typeof(b) c;
\end{minted}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\begin{minted}[linenos=false]{c}
int a;
int b;
int c;
\end{minted}
\end{minipage}

On préférera le code de droite pour des raisons d'élégance et de simplicité. Plus un code est lisible, mieux cela est. Par ailleurs, le programme de droite sera compilé un peu plus vite que celui de gauche. \textit{Il est inutile d'être trop intelligent.}\footnote{Enfin, la bêtise c'est quand même très rigolo. C'est une question d'humour au fond :)}
\subsection{Entiers signés et non signés}
Il est possible en langage C de choisir pour les nombres entiers entre l'interprétation signée de sa représentation binaire, et l'interprétation non signée. Cela se fait par les mot-clés \textsf{signed} et \textsf{unsigned}. Par défaut, les variables entières sont interprétés comme signées. Ainsi, le mot-clé \textsf{signed} n'est pas utile au moment de la déclaration de la variable. Cela peut être cependant utile pour une réinterprétation ultérieure (voir \textbf{Projection de type}). La syntaxe est la suivante :
\begin{minted}[linenos=false]{c}
char v = 130; // signé par défaut. La vérité est que v = 2 - 128 = -126
unsigned short int v2 = -1; // interpretation non signée, la vérité est que v2 = 65535
signed int v3 = -4; // 'signed' est inutile car implicite
// etc...
\end{minted}
\textbf{Remarque :} Le langage C ne propose pas de nombres flottants non signés car le standard de représentation des nombres flottants implique directement la présence du signe.
\subsection{Introduction à la portée des variables : les blocs}
Les variables sont déclarés dans des blocs de portée. Ces blocs de portée sont indiqués par les accolades gauche et droite $\{$ et $\}$. Ils indiquent dans quelle région du programme les variables sont déclarés. En particulier, il est possible d'imbriquer les blocs entre eux. Cela permet de remplacer dans une certaine partie du code une variable par une autre du même. Cela peut être intéressant pour rester lisible et utiliser des variables qui correspondent toujours à leur utilité :
\begin{minted}{c}
#include <stdlib.h>

int main()
{ // Premier bloc
	int a = 5; // déclaré dans le bloc le plus haut de 'main'
	{ // Deuxième bloc inséré dans celui de 'main'
		// ici, 'a' vaut toujours 5
		double a = 3.14; // Pas le même 'a'
		// ici, 'a' vaut 3.14
	}
	// ici, 'a' vaut à nouveau 5
	return EXIT_SUCCESS;
}
\end{minted}
Ces blocs peuvent être définis partout dans un code. Il est possible de déclarer des variables dans ou hors de ces blocs.
 
En particulier, il est possible de définir des variables hors du bloc \textsf{main}. Ces variables sont dites globales car accessibles dans tous les blocs du programmes même ceux qui ne sont pas le bloc de la fonction \textsf{main}\footnote{On verra comment définir d'autres fonctions dans la section sur les \textbf{Routines} et on détaillera les notions d'espaces locaux et d'espace global dans le prochain chapitre, dans la section sur les classes de stockage.} :
\begin{minted}{c}
#include <stdlib.h>

int some_global_variable = VALUE;
int main() {
	char some_global_variable = OTHER_VALUE;
	// du code
}

// Un autre code peut aussi accéder à 'some_global_variable'
\end{minted}
\textbf{Remarque :} Maîtriser la portée des variables et ne pas garder déclarée une variable alors qu'elle n'est plus utile permet au compilateur d'optimiser le code machine produit. Par exemple, dans le code suivant :
\begin{minted}{c}
#include <stdlib.h>

int main() {
	{
		int v = VALUE;
		// utilisation de 'v'
	}
	// Un gros code
	{
		int v = ANOTHER_VALUE;
		// utilisation de 'v'
	}
	return EXIT_SUCCESS;
}
\end{minted}
$v$ possède une valeur particulière d'initialisation dans une région du code, puis une autre valeur particulière d'initialisation dans une autre région du code très éloignée de la première. Indiquer cela avec les blocs de portés permet d'indiquer au compilateur qu'il est inutile de stocker la valeur de $v$ entre les deux régions.
\subsection{Exercices}
\exercise{Interversion de variables par effet de bord} Écrire un programme en C qui initialise deux variables $a$ et $b$ de valeurs différentes. En initialisant au maximum une seule variable supplémentaire, échanger les valeurs des deux premières variables. Ainsi, si $a = 8$ et $b = 6$ à leurs initialisations, alors en fin d'exécution il faut avoir $b = 8$ et $a = 6$ sans que les assignations soient explicites. C'est-à-dire que le code ne doit pas à être modifié si les valeurs de $a$ et $b$ sont changées.
\end{document}