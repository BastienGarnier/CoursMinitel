\documentclass[../../../main.tex]{subfiles}
\begin{document}
Un aspect critique d'un langage de programmation est la possibilité de donner des noms aux objets informatiques construits et manipulés. En langage C, c'est le concept de \textit{variable} qui fournit une telle possibilité.

Les variables constituent la brique de base du langage. Une variable au sens informatique est un conteneur d'une donnée dont la valeur peut évoluer au cours de l'exécution du programme.
 
Cette donnée représente de l'information. Elle est donc numérique, bien que l'interprétation puisse être de toute nature : image, vidéo, chaîne de caractère, nombre entier ou à virgule, arbre informatique, etc\dots On peut par exemple penser à la représentation d'une couleur comme un triplet $(r, g, b, a)\in{\llbracket 0, 255\rrbracket^{4}}$, c'est-à-dire un mot binaire de quatre octets, et donc définir une variable de quatre octets qui stocke ces informations.
 
\subsubsection{Approximation de stockage des variables}
\label{ssub:approximation_de_stockage_des_variables} 
On considère dans un premier temps que les variables sont caractérisés par trois informations :
\begin{itemize}
	\item une \textit{étiquette}, aussi appelée le nom de de la variable
	\item une adresse mémoire
	\item une donnée sur $N$ octets (ou $8N$ bits) à cette adresse
\end{itemize}
Une variable peut être vue alors comme une ``case'' de $N$ octets dans la RAM, positionnée à une certaine adresse mémoire. Le langage C nous permet d'associer à cette adresse une étiquette, appelée le nom de la variable. Cette étiquette est oubliée après la compilation, et ne subsiste que l'adresse mémoire dans le programme en langage machine.\newline
Visuellement :

\begin{minipage}{\textwidth}
	\begin{center}
		\includesvg[width=.25\textwidth]{variable}
		\captionof{figure}{Schéma du stockage d'une variable}\label{img:variable}
	\end{center}
\end{minipage}

\subsubsection{Type d'une valeur de variable}
\label{ssub:type_d_une_valeur_de_variable}
\definition{Type}{
Une donnée est une séquence finie de bits (0 ou 1). Il faut interpréter cette donnée pour qu'elle soit utilisable dans un contexte de programmation. L'interprétation de données établit une correspondance entre un ensemble de données dit de \textit{représentation}\footnote{Donc un ensemble de séquences de 0 et de 1} et un ensemble quelconque d'éléments $E$. On peut de plus décrire des opérations sur $E$ qui permettent de manipuler la donnée abstraitement. Ces opérations sont calculés concrètement sur la base de la représentation. \\

La donnée de la correspondance et des opérations de manipulation des éléments est appelée un \textit{type abstrait}\footnote{Cette notion sera détaillée un peu dans la section \ref{sec:type_abstrait_de_donn_es}}. Il s'agit mathématiquement d'une structure algébrique complexe possédant potentiellement de nombreuses opérations.\footnote{Si les mathématiques pures permettent de travailler sur les propriétés complexes de structures simples, l'informatique se concentre sur l'étude de propriétés ``simples'' de structures complexes.} \\

On a vu un certain nombre d'interprétations dans le premier chapitre de la première partie ($btoi_{u}$, $btoi_{s}$, norme \textit{IEEE 754} et caractères ASCII).
}
Le langage C propose un certain nombre de types élémentaires directement intégrés au langage. Définir une variable selon un type du langage C consiste à délimiter une séquence de bits en mémoire qui seront mis en correspondance vers un ensemble donné.

Les ensembles mis en correspondances avec ces données en langage C sont des sous-ensembles de $\mathbb{Z}$ ou de $\mathbb{R}$\footnote{Ce qui indique soit une interprétation entière soit une interprétation flottante par la norme \textit{IEEE 754}}. Une correspondance supplémentaire entre $\llbracket 0; 127\rrbracket$ et les caractères de la langue anglaise vient en surcouche. 

Le type permet donc de délimiter les $N$ octets d'un mot binaire et de l'interpréter. Il n'y a plus besoin de savoir comment est manipulée la représentation interne de l'objet pour le manipuler correctement. Il suffit de connaître précisement l'ensemble abstrait représenté et les opérations définies sur cet ensemble.

Le langage C propose les types de base suivants :
\begin{itemize}
\item Anneaux $\frac{\mathbb{Z}}{2^N\mathbb{Z}}$, où $N$ varie selon la taille de la représentation :
\begin{itemize}
	\item \textsf{char} : valeur $v\in{\llbracket-128; 127\rrbracket}$ représentée par une donnée sur 1 octet (8 bits) 
	\item \textsf{short int} : valeur $v\in{\llbracket-2^{15}; 2^{15}-1\rrbracket}$ représentée par une donnée sur 2 octets (16 bits) 
	\item \textsf{int} : valeur $v\in{\llbracket-2^{31}; 2^{31}-1\rrbracket}$ représentée par une donnée sur 4 octets (32 bits) 
	\item \textsf{long int} : valeur $v\in{\llbracket-2^{63}; 2^{63}-1\rrbracket}$ représentée par une donnée sur 8 octets (64 bits)
\end{itemize}
\item En théorie\footnote{ L'implantation native du C sur ordinateur du type est imprécise, puisque nécessite une mémoire infinie. Il faudrait utiliser une implantation sous forme de fractions d'entiers.}, le corps $\mathbb{Q}$ :
\begin{itemize}
	\item \textsf{float} : valeur $v\in{\mathbb{R}_{f32}}$ représentée par une donnée sur 4 octets (32 bits)
	\item \textsf{double} : valeur $v\in{\mathbb{R}_{f64}}$ représentée par une donnée sur 8 octets (64 bits)
	\item \textsf{long double} : valeur $v\in{\mathbb{R}_{f128}}$ représentée par une donnée sur 16 octets (128 bits)
\end{itemize}
\item Pour représenter une adresse mémoire : \textsf{TYPE*} : donnée $d$ sur 8 octets contenant l'adresse d'une autre variable de type \textsf{TYPE}
\end{itemize}
\begin{minitelbasicbox}{\textbf{Petit apparté :} Rapport entre variable informatique et variable mathématique :}

Une variable en mathématique désigne un objet indéterminé et sans représentation. Cela semble au premier abord faux car il peut arriver qu'on écrive les phrases suivantes :
\begin{itemize}
	\item ``Soit $e\in{E}$. \dots'', où $E$ désigne un ensemble quelconque
	\item ``$\forall{x\in{E}}, \mathcal{P}(x)$'', où $E$ désigne un ensemble quelconque et $\mathcal{P}$ un prédicat monadique quelconque
\end{itemize}
En y regardant de plus près, on observe qu'il s'agit en fait simplement de facilités d'écriture équivalentes aux phrases suivantes :
\begin{itemize}
	\item ``Soit $e$ un objet indéterminé. Supposons $e\in{E}$. \dots'', où $E$ désigne un ensemble quelconque
	\item ``$\underset{x \text{ indéterminé}}{\forall{x}}, x\in{E}\implies{\mathcal{P}(x)}$'', où $E$ désigne un ensemble quelconque et $\mathcal{P}$ un prédicat monadique quelconque
\end{itemize}
Cet objet finit par ne plus être indéterminé du fait d'hypothèses à son propos.

Par ailleurs, la représentation de cet objet ne lui est pas intrinsèque mais dû à des conventions d'écriture et de notation.
 
D'un autre côté, les variables informatiques n'évoluent pas dans le contexte d'une démonstration. Elles sont en fait directement liés au concept physique d'un ordinateur comme des identifiants associées à des adresses mémoire. À cette adresse mémoire est stockée une donnée sous forme d'un mot binaire. Les mots binaires dans la mémoire d'un ordinateur fournissent une représentation intrinsèque des variables informatique (et en fait de tous les objets manipulés sur un ordinateur).

Les variables peuvent alors potentiellement évoluer et changer de valeur -- par la modification des données qui leurs sont associées -- au cours du temps. Cette notion de temporalité logique est tout à fait absente du concept de variable mathématique.
\end{minitelbasicbox}
La syntaxe du langage C pour déclarer une variable d'un type quelconque \textsf{TYPE} est la suivante :
\begin{minted}[linenos=false]{c}
TYPE any_variable; // variable non initialisée : valeur indéterminée
TYPE any_variable = ANY_VALUE; // initialisée à la valeur ANY_VALUE
\end{minted}
Il n'est pas possible en C de déclarer deux fois un même identifiant. Ainsi, le code suivant provoque une erreur à la compilation :
\begin{minted}[linenos=false]{c}
int age = 20; // déclare age comme un entier de valeur 20
char age = 19; // ERREUR : age déjà déclaré
\end{minted}
Ainsi, un identifiant déclaré avec un certain type ne peut pas en changer jusqu'à ce qu'il ne soit plus définit (c'est-à-dire souvent jusqu'à la fin de l'exécution du programme). Après ne plus être défini, il pourra l'être à nouveau avec un autre type. Cela sera vu avec les \textit{espaces de noms}.
 
\textbf{Remarque 1 :} L'exécution d'un programme en C est séquentielle. Pour cette raison, on ne peut référer à une variable qu'après l'avoir déclarée :
\begin{minted}[linenos=false]{c}
test = 2; // ERREUR : 'test' n'est pas encore déclaré
int test;
\end{minted}
Pour cette raison, toutes les variables doivent être déclarées avant tous les lieux du code où elles se trouvent référencées.
 
\textbf{Remarque 2 :} le symbole \textsf{=} est un symbole d'\textit{assignation}. Contrairement aux conventions mathématiques, il ne définit par une fonction binaire renvoyant $Vrai$ si les deux objets sont égaux. Il permet cependant de changer à tout instant la valeur d'une variable déjà définie :
\begin{minted}[linenos=false]{c}
int nombre_de_feuilles = 2000;
nombre_de_feuilles = 1000; // Assigne à la variable nombre_de_feuilles la valeur 1000
\end{minted}

\begin{minitelbasicbox}{\textbf{Petit apparté} : le type \textsf{char}}
Les caractères ASCII ont été abordés dans la première partie. \textsf{char} signifie \textit{character} en anglais, c'est-à-dire \textit{caractère} en français.

Le langage C propose le même type pour pour faire correspondre le sous-ensemble des entiers $\llbracket-128; 127\rrbracket$ et l'ensemble des caractères ASCII, bien que l'interprétation soit différente. Cela est compréhensible puisque les mots binaires utiles pour ces deux interprétations sont les mêmes, il s'agit cependant d'une petite bizarrerie conceptuelle du langage\footnote{Et ce n'est pas la seule, le C n'ayant peut-être pas été conçu "à l'arrache" mais en tout cas certainement pas de manière super carrée\dots il suffit de voir les tableaux statiques.}. On peut écrire un caractère ASCII grâce aux guillements simples :
\begin{minted}{c}
char carac = 'z';
\end{minted}
ce qui revient strictement à écrire :
\begin{minted}{c}
char carac = 122;
\end{minted}
\end{minitelbasicbox}

On observe une équivalence stricte entre les expressions suivantes : 

\begin{minipage}{0.5\textwidth}
\begin{minted}[linenos=false]{c}
// Première expression :
TYPE variable = valeur;

\end{minted}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\begin{minted}[linenos=false]{c}
// Deuxième expression :
TYPE variable; // valeur indéterminée
variable = valeur;
\end{minted}
\end{minipage}

La première expression est une facilité d'écriture très largement utilisée\footnote{Appelée \textit{sucre syntaxique} dans certains milieux ;-)}
 
En conséquence, le code suivant est tout à fait correct, bien qu'inutile sous cette forme :
\begin{minted}[linenos=false]{c}
int a = a; // La valeur de 'a' est toujours indéterminée
\end{minted}
En effet, le symbole $a$ est déclaré avant l'assignation.
\subsection{Taille et type d'une variable}
\label{sub:taille_et_type_d_une_variable}
Il est possible de récupérer la taille d'une variable après l'avoir déclarée, ainsi que son type (depuis la version \textit{C23})
 
Cela est effectué par les opérateurs unaires \textsf{sizeof} et \textsf{typeof}.
 
\subsubsection{Opérateur \textsf{sizeof}}
 \label{ssub:op_rateur_textsf_sizeof}
L'opérateur \textsf{sizeof} est particulièrement commun. Son exécution est quasiment systématiquement effectuée \textit{à la compilation}. En effet, il retourne une valeur numérique précalculable. La valeur du résultat est donc remplacée dans le code à la génération de l'exécutable.
 
\textsf{sizeof} renvoie le nombre d'octets $N$ nécessaires au stockage de l'espace mémoire associé à une étiquette ou un type. On utilise en général \textsf{sizeof} sur les types :
\begin{minted}[linenos=false]{c}
sizeof(char); // 1
sizeof(short int); // 2
sizeof(int); // 4
sizeof(long int); // 8
sizeof(float); // 4
sizeof(double); // 8
sizeof(long double); // 16

TYPE a;
sizeof(a); // Nombre d'octets pour stocker 'a' en mémoire
sizeof(TYPE); // idem
\end{minted}
\textbf{Remarque :} L'opérateur \textsf{sizeof} renvoie une valeur de type \textsf{size\_t}, équivalente à un \textsf{long int}.

\subsubsection{Opérateur \textsf{typeof} (pour la culture uniquement)}
\label{ssub:op_rateur_textsf_typeof}
L'opérateur \textsf{typeof}, tout comme \textsf{sizeof}, est calculé au moment de la compilation. D'ailleurs, effectuer un tel calcul durant l'exécution du programme n'a aucun sens. En effet, \textsf{typeof} renvoie le type d'une variable. Les deux codes suivants sont donc strictement équivalents : 

\begin{minipage}{0.5\textwidth}
\begin{minted}[linenos=false]{c}
typeof(int) a;
int b;
typeof(b) c;
\end{minted}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\begin{minted}[linenos=false]{c}
int a;
int b;
int c;
\end{minted}
\end{minipage}

On préférera le code de droite pour des raisons d'élégance et de simplicité. Plus un code est lisible, mieux cela est. Par ailleurs, le programme de droite sera compilé un peu plus vite que celui de gauche. \textit{Il est inutile d'être trop intelligent.}\footnote{Enfin, la bêtise c'est quand même très rigolo. C'est une question d'humour au fond :)}
\subsection{Entiers signés et non signés}
\label{sub:entiers_sign_s_et_non_sign_s}
Il est possible en langage C de choisir pour les nombres entiers entre l'interprétation signée de sa représentation binaire, et l'interprétation non signée. Cela se fait par les mot-clés \textsf{signed} et \textsf{unsigned}. Par défaut, les variables entières sont interprétés comme signées. Ainsi, le mot-clé \textsf{signed} n'est pas utile au moment de la déclaration de la variable. Cela peut être cependant utile pour une réinterprétation ultérieure (voir \textbf{Projection de type}). La syntaxe est la suivante :
\begin{minted}[linenos=false]{c}
char v = 130; // signé par défaut. La vérité est que v = 2 - 128 = -126
unsigned short int v2 = -1; // interpretation non signée, la vérité est que v2 = 65535
signed int v3 = -4; // 'signed' est inutile car implicite
// etc...
\end{minted}
\textbf{Remarque :} Le langage C ne propose pas de nombres flottants non signés car le standard de représentation des nombres flottants implique directement la présence du signe.

\subsection{Environnement et blocs}
\label{sub:environnement_et_blocs}
\definition{Environnement global}{Il semble clair que la possibilité d'associer à des symboles à des valeurs et y accéder plus tard signifie que le compilateur doit garder quelque part en mémoire les paires $(\textit{objet}, \textit{nom})$. Cette mémoire est appelée l'\textit{environnement du programme}, et plus précisement l'environnement \textit{globale}.

Cet environnement global désigne un espace de noms. La fonction \textsf{main} est un de ces noms, et à ce nom est associé des instructions, un code.
}

\definition{Environnement local}{
	Un environnement local est un sous-espace de noms, relatif à environnement plus global que lui. Les paires $(\textit{nom}, \textit{valeur})$ d'un environnement local ne sont pas accessibles hors de cet environnement.

	Toutefois, une paire $(\textit{nom}, \textit{valeur})$ définie dans un environnement $A$ est également définie dans tous les sous-espaces de noms de $A$.
}

Un environnement local est défini en langagee C par un bloc de portée. Les blocs de portée sont indiqués par les accolades gauche et droite $\{$ et $\}$. Ils délimitent un environnement local dans lequel des variables pourront être définies. En particulier, il est possible d'imbriquer les blocs entre eux, c'est-à-dire de créer des sous-environnements locaux d'environnements locaux :
\begin{minted}{c}
#include <stdlib.h>

// 'main' est déclarée dans l'environnement global :

int main()
{ // Premier bloc : environnement local de 'main'

	int a = 5; // déclaré dans l'environnement local de 'main'

	{ // Définit un sous-environnement local dans 'main'

		// ici, 'a' vaut toujours 5
		
		double a = 3.14; // Déclaration d'une nouvelle paire nom-valeur pour 'a'
		
		// ici, 'a' vaut 3.14
	
	} // sortie du sous-environnement local

	// 'a' vaut à nouveau 5
	
	return EXIT_SUCCESS;
} // sortie de l'environnement local de 'main'

\end{minted}
\textbf{Remarque :} Le code ci-dessous montre que la déclaration d'une variable dans un sous-environnement local est prioritaire sur la définition précédente d'une variable de même nom dans un environnement hiérarchiquement supérieur.

Ces blocs peuvent être définis partout dans un code. Il est possible de déclarer des variables dans ou hors de ces blocs.
 
En particulier, il est possible de définir des variables hors du bloc \textsf{main}. Ces variables appartiennent alors comme \textsf{main} à l'environnement global du programme.

Ces variables sont alors dites globales. Elles sont accessibles dans tous les blocs du programmes même ceux qui ne sont pas le bloc de la fonction \textsf{main} :
\begin{minted}{c}
#include <stdlib.h>

int some_global_variable = VALUE;
int main() {
	char some_global_variable = OTHER_VALUE;
	// du code
}

// Un autre code peut aussi accéder à 'some_global_variable' et à 'main'
\end{minted}
\textbf{Remarque :} il est assez rare d'avoir à utiliser la fonction \textsf{main} hors de celle-ci durant l'exécution du programme.

\textbf{Cas d'application réel :} On essaie en général d'alléger, dans la mesure où cela est utile\footnote{Je veux dire\dots Créer un sous-environnement local pour \textit{chaque} contexte de variable, c'est un peut-être un peu abusé. Quoique\dots}, les environnements les plus globaux. Cela permet principalement de réduire la taille de l'espace des noms utilisés à un endroit donné du programme et donc de réduire les bugs d'origine humaine qui consistent à réutiliser deux fois le même nom d'un même environnement dans des contextes différents.
\subsection{Exercices}
\exercise{Interversion de variables par effet de bord}{10} Écrire un programme en C qui initialise deux variables $a$ et $b$ de valeurs différentes. En déclarant au maximum une seule variable supplémentaire, échanger les valeurs des deux premières variables. Ainsi, si $a = 8$ et $b = 6$ à leurs initialisations, alors en fin d'exécution il faut avoir $b = 8$ et $a = 6$ sans que les assignations soient explicites. C'est-à-dire que le code ne doit pas avoir à être modifié si les valeurs de $a$ et $b$ sont changées.
\end{document}