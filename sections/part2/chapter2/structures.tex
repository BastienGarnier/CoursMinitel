\documentclass[../../../main.tex]{subfiles}
\begin{document}
Pour l'instant, seules les types élémentaires ont été vues, c'est-à-dire les nombres entiers et flottants, codés sur un, deux, quatre, huit ou dix octets. Il aussi été vu comment créer des tableaux de ces types, statiques ou dynamiques.
 
Supposons cependant que l'on veuille modéliser informatiquement des structures complexes, comme par exemple :
\begin{itemize}
	\item la modélisation d'une lentille dans une simulation physique par une taille, la modélisation de sa forme par des courbes paramétriques, les propriétés du matériau, etc\dots
	\item le bouton d'une application par une taille, une position dans l'espace, une couleur, un texte, etc\dots
	\item un personnage d'un jeu vidéo. Celui-ci possède, par exemple, des points de vie, une vitesse, un modèle 3D qui est (grossièrement) un tableau de sommets, d'arêtes et de faces, etc\dots
	\item etc\dots
\end{itemize}
On pourrait stocker tout ceci dans des tableaux toujours plus grands d'entiers dont on peut interpréter les valeurs. 
Il faudrait noter dans une documentation que le $34^e$ octet correspond à l'accélération selon l'axe $z$ par exemple. Il faudrait ensuite penser à effectuer une projection de type en nombre flottant, puisqu'un tableau ne peut pas contenir des éléments de plusieurs types différents.
 
C'est possible. Mais cela semble plutôt complexe, et d'un sens pratique assez\dots comment dire\dots limité.
 
C'est ici que les structures entrent en jeu.

Une structure permet de définir un type complexe. C'est un moyen de stocker dans une seule entité plusieurs types d'informations. Chacune de ces informations possédera sa propre étiquette au sein de cette entité, ainsi que son propre type. C'est un peu comme une boîte qui contient plusieurs variables : 

\begin{minipage}{\textwidth}
	\begin{center}
		\includesvg[width=.25\textwidth]{structure}
	\end{center}
\end{minipage}
 
La syntaxe de définition d'une structure en C est la suivante :
\begin{minted}[linenos=false]{c}
struct NomStructure { // Aucun objet n'est créé, il s'agit d'une description
	TYPE1 var1;
	TYPE2 var2;
	TYPE3 var3;
	// etc...
};
\end{minted}
Il s'agit d'une définition, et non d'une déclaration. \textit{On définit un nouveau type}. Pour cette raison, aucune variable interne, ou \textit{membre}, de la structure ne peut être initialisée. Pour utiliser une structure, il faut au final créer des variables dont le type est cette structure :
\begin{minted}[linenos=false]{c}
struct NomStructure x; // 'x' est créé sans membres initialisés.
\end{minted}
Il est possible d'y penser un peu comme à la construction d'une maison : on commence par dessiner le plan de la maison et une fois cela fait il suffit de fabriquer plein de maisons grâce à ce plan.
 
On peut ensuite accéder aux membres d'une structure via un nouvel opérateur binaire, l'opérateur d'accès à un membre noté ``.'' :
\begin{minted}[linenos=false]{c}
x.var1 = ...; // accède au membre 'var1' de 'x'
x.var2 = ...; // accède au membre 'var2' de 'x'
x.var3 = ...; // accède au membre 'var3' de 'x'
// etc...
\end{minted}
Un exemple :
\begin{minted}{c}
#include <stdio.h>
#include <stdlib.h>

struct Point3D {
	double x;
	double y;
	double z;
};

int main() {
	struct Point3D p;
	p.x = 1.0;
	p.y = 2.0;
	p.z = -3.0;
	printf("p = (%lf, %lf, %lf)\n", p.x, p.y, p.z);

	return EXIT_SUCCESS;
}
\end{minted}
\textbf{Remarque 1 :} Une structure ne peut contenir au maximum que 127 membres.
 
\textbf{Remarque 2 :} Au contraire des tableaux statiques, toute structure définie est considérée comme une entité de première classe. Ainsi, il est possible d'écrire des routines dont les paramètres sont des structures, et qui prennent en argument des structures identiques :
\begin{minted}{c}
#include <stdio.h>
#include <stdlib.h>

struct Point3D {
	double x;
	double y;
	double z;
};

void afficher(struct Point3D p) {
	printf("(%lf, %lf, %lf)\n", p.x, p.y, p.z);
}

int main() {
	struct Point3D p;
	p.x = 1.0;
	p.y = 2.0;
	p.z = -3.0;
	afficher(p);

	return EXIT_SUCCESS;
}
\end{minted}
\textbf{Remarque :} Il est aussi possible qu'un membre d'une structure soit lui-même une structure :
\begin{minted}{c}
#include <stdio.h>
#include <stdlib.h>

struct Couple {
	double x;
	double y;
};

struct Line {
	struct Couple point;
	struct Couple direction;
};

// ou encore :

struct Line {
	struct Couple {
		double x;
		double y;
	} point;
	struct Couple direction;
};

int main() {
	struct Line l;
	// . est un opérateur associatif :
	l.point.x = 0.0;
	l.point.y = 1.0;
	l.direction.x = 1.0;
	l.direction.y = 2.5;

	return EXIT_SUCCESS;
}
\end{minted}
\subsection{Initialisation à la déclaration}
\label{sub:initialisation_la_d_claration}
L'initialisation de structures contenant une grande quantité de variables peut vite être fastidieuse. Le langage C propose deux facilités d'écriture pour initialiser les variables statiques (c.à.d obtenues sans allocation dynamique) d'une structure dès la déclaration d'une instance : 

\begin{minipage}{0.5\textwidth}
\begin{minted}[linenos=false]{c}
struct MyStruct {
	int a;
	char b;
	void *c; // pointeur quelconque
	long double d; 
};

 // Initialisation séquentielle
struct MyStruct s = {
	2<<20,
	6,
	NULL,
	3.141592653589
};
\end{minted}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\begin{minted}[linenos=false]{c}
struct MyStruct {
	int a;
	char b;
	void *c; // pointeur quelconque
	long double d;
};

// Initialisation sélective
struct MyStruct s = {
	.d =	3.141592653589,
	.a = 2<<20,
	.c = NULL,
	.b = 6
}; 
\end{minted}
\end{minipage}

L'initialisation séquentielle suit exactement l'ordre des membres de la structure.
\newline
L'initialisation sélective permet de choisir très exactement quel membre reçoit quelle valeur.
 
\textbf{Remarque :} Les retours à la ligne sont optionnels et ne servent qu'à la lisibilité. Le code suivant est valide :
\begin{minted}[linenos=false]{c}
struct Point {
	double x;
	double y;
};

struct Point p = {.y = 4.5, 3.2}; // Pointe vers x = 3.2, y = 4.5
\end{minted}
Il est parfaitement possible de mélanger les initialisations séquentielles et sélectives. Dans un tel cas, l’initialisation séquentielle reprend au dernier membre désigné par une initialisation sélective. Partant, le code suivant initialise le membre $a$ à 1 et le membre $d$ à 30.560.
\begin{minted}[linenos=false]{c}
struct MyStruct s = {1, .d = 30.560};
\end{minted}
Alors que le code ci-dessous initialise le membre $c$ à \textsf{NULL}, le membre $d$ à 48, le membre $b$ à 0 et le membre $c$ à $\&s$.
\begin{minted}[linenos=false]{c}
struct MyStruct s = {.c = NULL, 48, .b = 0, &s}; // d non initialisé
\end{minted}
\subsection{Méchanisme de construction}
La question ici est de comprendre quel est le méchanisme qui permet d'accéder à chacun des champs d'une structure à partir de sa définition, c'est-à-dire comment fonctionne l'opérateur d'indirection.

L'objectif, en particulier, est de montrer que l'utilisation de structures et l'utilisation de l'opérateur d'accès à un membre ne ralentissent pas l'exécution d'un programme.

Pour mieux comprendre comment les données sont stockées, on exécute le programme suivant :
\begin{minted}{c}
#include <stdio.h>
#include <stdlib.h>

struct Something {
	int a;
	short int b;
	char c;
};

int main() {
	struct Something s = {.a = 0x01234567, .b = 0x89AB, .c = 0xCD};

	printf("Taille de la structure : %lu\n", sizeof(struct Something));

	// permet d'accéder à la structure octet par octet :
	unsigned char *ptr = (unsigned char*)&s; 
	for (unsigned int i = 0; i < sizeof(struct Something); i++) {
		printf("octet %u : 0x%02x\n", i, ptr[i]);
	}

	return EXIT_SUCCESS;
}
\end{minted}
À l'exécution, on observe le résultat suivant :
\begin{minted}{bash}
user@computer ~/working_directory> ./main
Taille de la structure : 8
# s.a :
octet 0 : 0x67
octet 1 : 0x45
octet 2 : 0x23
octet 3 : 0x01
# s.b :
octet 4 : 0xab
octet 5 : 0x89
# s.c :
octet 6 : 0xcd
# padding
octet 7 : 0x00
\end{minted}
On observe que :
\begin{itemize}
	\item les champs sont contenus les uns à la suite des autres, de manière compacte
	\item les octets sont inversés, par petit boutisme (\url{https://fr.wikipedia.org/wiki/Boutisme})
	\item un octet est ajouté à la fin de la structure \textit{``sans raisons apparentes''}
\end{itemize}
On discute du troisième point dans la sous-section \ref{sub:alignement} suivante.

La compacité des structures est logique dans un souci d'optimisation spatiale. Elle signifie en particulier que les champs d'une structure n'existent pas indépendamment en mémoire. Cela justifie notamment la possibilité de définir des tableaux de structures (voir section suivante).

En particulier, on peut accéder aux champs de la manière suivante :
\begin{minted}[linenos=false]{c}
struct Something {
	int a;
	short int b;
	char c;
};

...

struct Something s = {.a = 0x01234567, .b = 0x89AB, .c = 0xCD};
void *ptr = (void*)&s;

s.a == (int)(*(ptr + 0));
s.b == (short int)(*(ptr + sizeof(s.a)));
s.c == (char)(*(ptr + sizeof(s.a) + sizeof(s.b)));
\end{minted}
\textbf{Remarque :} les assertions sont correctes car \textsf{struct Something} est correctement aligné (voir la sous-section \ref{sub:alignement} suivante).

Les adresses des champs d'une instance de structure sont seulement des décalages (\textit{offsets} en anglais) vis-à-vis de l'adresse de l'instance elle-même.

Comme ces décalages sont calculés à la compilation programme, l'opération d'accès à un membre peut aussi être calculée à la compilation.

L'utilisation de structures ne ralenti donc pas l'exécution du programme.
\subsection{Tableaux de structures}
\label{sub:tableaux_de_structures}
Comme les structures définies sont considérés comme des entités de première classe et sont compactes en mémoire, il est évidemment possible de créer statiquement des tableaux de ces structures :
\begin{minted}{c}
#include <stdio.h>
#include <stdlib.h>

struct Time {
	short int milliseconds;
	char hour;
	char minutes;
	char seconds;
}

int main() {
	int i = ...;
	struct Time running_times[10];
	running_times[i].hour = ...;
	return EXIT_SUCCESS;
}
\end{minted}
On peut également effectuer des allocations dynamiques avec les pointeurs par le \textsf{malloc}. Son utilisation est identique à celle permettant l'allocation dynamique de tableaux de types intrinsèques au langage :
\begin{minted}{c}
...

int main() {
	int i = ...;
	struct Time* running_times = malloc(sizeof(struct Time) * 10);
	running_times[i].hour = ...;
	return EXIT_SUCCESS;
}
\end{minted}
Il est ainsi possible de travailler sur des pointeurs de structure :
\begin{minted}{c}
#include <stdio.h>
#include <stdlib.h>

struct Something {
	int a;
	char b;
};

int function(struct Something* s_ptr) {
	(*s_ptr).a += (*s_ptr).b;
	return (*s_ptr).a;
}

int main() {
	struct Something s;
	s.a = 0;
	s.b = 1;
	for (int i = 0; i < 10; i++) {
		s.b = function(&s) / s.b;
	}
	printf("%d\n", s.a);
	return EXIT_SUCCESS;
}
\end{minted}
On observe que l'opérateur d'accès à un membre est prioritaire sur l'opérateur d'indirection $*$\footnote{En effet, l'opérateur d'accès à un membre ne fait qu'ajouter un décalage à l'adresse de la variable structurée pour accéder au membre de la structure. Ce calcul est effectué par le compilateur. Pour cette raison, l'opérateur d'accès à un membre fait partie des opérateurs les plus prioritaires du langage (voir sous-section précédente)}. Oublier de parenthéser amène à une erreur puisque \textsf{ptr.member} n'existe pas. En effet, un pointeur n'est qu'une adresse vers la structure. Il n'a donc pas de membres. \newline
La notation est cependant très lourde à écrire, alors une notation purement facilitatrice existe en C, la flèche :
 
\begin{minipage}{0.5\textwidth}
\begin{minted}[linenos=false]{c}
struct MyStruct {
	int a;
	int b;
};

struct MyStruct *s = ...;

printf("a = %d, b = %d\n", s->a, s->b);
\end{minted}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\begin{minted}[linenos=false]{c}
struct MyStruct {
	int a;
	int b;
};

struct MyStruct *s = ...;

printf("a = %d, b = %d\n", (*s).a, (*s).b);
\end{minted}
\end{minipage}
\subsection{Alignement et optimisation des structures}
\label{sub:alignement}
On aborde ici un point technique ayant à voir avec l'optimisation du code de manière générale, et plus précisément l'optimisation des structures.

Si un processeur tente d'accéder à une valeur codée sur $N$ octets située à une adresse $a \not\equiv 0\ [N]$, il va devoir effectuer des calculs supplémentaires pour se décaler de la valeur du modulo et se trouve ralenti.

Ainsi, on veut que l'adresse d'un \textsf{int} soit un multiple de 4 octets, que l'adresse d'un \textsf{char} soit multiple de 1 octet, que l'adresse d'un \textsf{double} soit multiple de 8 octets, etc\dots

\definition{Alignement}{On dit qu'une donnée d'adresse $a$ est alignée sur $N$ octets si $a \equiv 0 [N]$}

On cherche donc à aligner les adresses des objets sur leurs taille.

Prenons les deux structures suivantes :

\begin{minipage}{0.5\textwidth}
\begin{minted}{c}
struct ExampleUnaligned {
	char c;
	int a;
	short b;
};

struct ExampleUnaligned x;
\end{minted}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\begin{minted}{c}
struct ExampleAligned {
	int a;
	short b;
	char c;
};

struct ExampleAligned x;
\end{minted}
\end{minipage}

Les deux structures \textit{semblent} équivalentes, pourtant elles ne le sont pas.

Pour garantir l'alignement de la donnée de plus grande taille, on aligne les structures elles-mêmes sur cette plus grande taille. Ainsi, chacune des deux structures est alignée sur 4 octets.

\textbf{Dans le cas de la structure \textsf{ExampleAligned} :}
\begin{itemize}
	\item $x.a$ est à l'adresse $\&x$, donc aligné sur 4 octets, ce qui est correct
	\item $x.b$ est à l'adresse $\&x + 4$, donc aligné sur 2 octets, ce qui est correct
	\item $x.c$ est à l'adresse $\&x + 6$, donc aligné sur 1 octet, ce qui est correct
\end{itemize}

\textbf{Dans le cas de la structure \textsf{ExampleUnaligned} :}
\begin{itemize}
	\item $x.c$ est à l'adresse $\&x$, donc aligné sur 1 octet, ce qui est correct
	\item $x.a$ est, \textit{a priori}, à l'adresse $\&x + 1$, donc \textit{non aligné} sur 4 octets
	\item $x.b$ est, \textit{a priori}, à l'adresse $\&x + 5$, donc \textit{non aligné} sur 2 octets 
\end{itemize}

Ainsi, la structure \textsf{ExampleUnaligned} devrait être plus lente que la structure \textsf{ExampleAligned}.

Le compilateur effectue cependant un alignement automatique lors de la génération du code des structures pour que chaque adresse des champs d'un objet de type complexe, défini par une structure, soit congrue à la taille de la donnée.

Dans le cas de la structure \textsf{ExampleUnaligned} :
\begin{itemize}
	\item $x.c$ est toujours à l'adresse $\&x$
	\item $x.a$ est placé à l'adresse $\&x + 4$ pour forcer l'alignement
	\item $x.b$ est placé à l'adresse $\&x + 8$ pour forcer l'alignement
\end{itemize}
La taille de la structure devient $10$.

Si on veut pouvoir créer un tableau de cette structure sans problèmes d'alignement, il faut arrondir la taille de la structure à son alignement, donc à $12$.

Finalement, $\textsf{sizeof(struct ExampleUnaligned)} = 12$, tandis que $\textsf{sizeof(struct ExampleAligned)} = 8$.
\subsection{Exercices}
\exercise{Matrices (2)}{13} Écrire une structure \textsf{struct Matrix} qui contient trois champs :
\begin{itemize}
	\item \textit{double** mat};
	\item \textit{unsigned int n};
	\item \textit{unsigned int m};
\end{itemize}
et modifier les routines de l'\refexercise{Matrices (1)} pour qu'elles utilisent la structure \textsf{struct Matrix}.

\exercise{Optimisation d'alignement}{03} Déterminer les tailles des structures \textsf{ExampleAligned} et \textsf{ExampleUnaligned} avec un \textsf{double} à la place d'un \textsf{int}.

\exercise{Listes chainées}{27}L'objectif de cet exercice est d'introduire une nouvelle manière de structurer les données. La structure de données dite de \textit{liste chaînée} permet de stocker des données non adjacentes en mémoire, au contraire des tableaux. Les \textit{listes chaînées} ont l'avantage inédit par rapport aux tableaux de pouvoir changer de taille au cours de l'exécution du programme. Il devient possible d'ajouter ou de supprimer des éléments \textit{dynamiquement}. On peut ainsi imaginer une liste d'items d'un utilisateur qui pourrait s'accroitre indéfiniment\footnote{Dans la limite de la mémoire de l'ordinateur}, comme un carnet d'adresses par exemple.
 
On commence par construire la structure permettant de stocker un \textit{noeud} de la liste, c'est-à-dire un de ses éléments. La valeur du noeud est la valeur de l'élément de la liste :
 
\begin{minipage}{\textwidth}
	\begin{center}
		\includesvg[width=\textwidth]{node}
		\captionof{figure}{Noeud d'une liste}\label{img:node}
	\end{center}
\end{minipage}

L'idée fondamentale des listes chaînées est que chaque noeud sera alloué dynamiquement et sera donc situé dans un espace mémoire indépendant de celui des autres noeuds. Cela permet de libérer la mémoire allouée pour un noeud en conservant les autres noeuds, ou encore d'allouer de nouveaux noeuds sans avoir à s'occuper des adresses des autres noeuds.

En utilisant un pointeur temporaire vers les noeuds, on peut passer d'un noeud à l'autre grâce aux pointeurs $next$ et $previous$.
\begin{enumerate}
	\item Définir une structure \textsf{struct Node} qui contient un entier $value$ (la valeur du noeud) et deux pointeurs vers une structure \textsf{struct Node} appelés $next$ et $previous$ (qui permettront de \textit{pointer} vers les noeuds suivant et précédent de la liste)
	\item Écrire une fonction \textsf{struct Node* node\_new(int value);} qui alloue dynamiquement une structure \textsf{struct Node* nd} initialisée telle que :
	\begin{itemize}
		\item $nd\rightarrow next$ et $nd\rightarrow previous$ ne pointent sur rien
		\item $nd\rightarrow value = value$
	\end{itemize}
	\item Définir une structure \textsf{struct LinkedList} qui contient un entier $length$ (le nombre de noeuds) et deux pointeurs vers une structure \textsf{struct Node} appelés $head$ et $tail$. La \textit{tête} de liste est le premier noeud de la liste. La \textit{queue} de liste est le dernier noeud de la liste. On obtient grâce à cette structure de liste le schéma suivant (ici, une liste de trois éléments de valeurs $V_{1}$, $V_{2}$ et $V_{3}$) :

	\begin{minipage}{\textwidth}
	\begin{center}
	\includesvg[width=\textwidth]{liste}
	\end{center}
	\end{minipage}
	\item Écrire une fonction \textsf{struct LinkedList* linkedlist\_new();} qui alloue dynamiquement une structure \textsf{struct LinkedList* lst} initialisée telle que :
	\begin{itemize}
		\item $lst\rightarrow head$ et $lst\rightarrow previous$ ne pointent sur rien
		\item $lst\rightarrow length = 0$
	\end{itemize}
	\item Écrire une fonction \textsf{char linkedlist\_is\_empty(struct LinkedList *l);} qui renvoie \textsf{1} si la liste est vide, et renvoie \textsf{0} sinon.
	\item Écrire une procédure \textsf{void linkedlist\_push\_on\_head(struct LinkedList *l, int value);} qui crée un noeud de valeur $value$ et l'insère \textit{en tête de liste}, c'est-à-dire qu'après insertion la valeur de la \textit{tête} sera $value$. On pensera à traiter séparément le cas où la liste est vide (c'est-à-dire $lst\rightarrow length = 0$). En effet, on rappelle que si $lst\rightarrow head$ ne pointe sur rien, le considérer comme un noeud provoque une erreur du fait de l'accès à une zone mémoire non autorisée. Par ailleurs, si la liste contient un unique élément, la \textit{tête} est égale à la \textit{queue}.

	\textbf{Attention :} la difficulté principale réside dans le fait de relier correctement les noeuds entre eux grâce aux pointeurs. Il faut faire preuve de rigueur pour qu'après exécution de la fonction on ait bien le schéma ci-dessus.
	\item De même, écrire une procédure \textsf{void linkedlist\_push\_on\_tail(struct LinkedList *l, int value);} qui crée un noeud de valeur $value$ et l'insère \textit{en queue de liste}.
	\item Écrire deux fonctions \textsf{int linkedlist\_pop\_from\_head(struct LinkedList *l);} et \textsf{int linkedlist\_pop\_from\_tail(struct LinkedList *l);} qui suppriment respectivement le noeud en tête et en queue de liste et renvoient la valeur de ce noeud. On pensera à libérer la mémoire associée à l'allocation dynamique de ce noeud (c'est-à-dire utiliser \textsf{free} sur le pointeur vers le noeud).
	\item Écrire une fonction \textsf{void linkedlist\_destroy(struct LinkedList *l);} qui détruit une liste en libérant la mémoire de chacun de ses noeuds et de la liste elle-même.
	\item En utilisant un pointeur temporaire vers les noeuds, écrire une procédure \textsf{void linkedlist\_display(struct LinkedList *l);} qui affiche les valeurs des noeuds de la liste.
\end{enumerate}
% \exercise{Raymarching}Un environnement procédural est un environnement généré par des procédures, constitués de calculs mathématiques. L'algorithme de \textit{raymarching} permet de visualiser depuis un point de l'espace un tel environnement, comme le ferait une caméra\footnote{Voir \url{https://www.youtube.com/watch?v=BFld4EBO2RE} pour une démonstration de création d'un environnement procédural par un ancien ingénieur de Pixar.}
% Cet exercice \textit{extrêmement guidé} présente, en deux dimensions, le principe de l'algorithme de \textit{raymarching} utilisé pour visualiser de tels environnements.
% \begin{enumerate}
%	 \item Définir une structure \textsf{struct Point} modélisant un point en coordonnées flottantes sur 64 bits dans un espace euclidien à deux dimensions
%	 \item Écrire une fonction \textsf{struct Point point\_new(double, double);} qui renvoie un point situé aux coordonnées indiquées
%	 \item En ajoutant l'option \textit{-lm} à la ligne de commande lors de la compilation avec \textsf{gcc}, on peut utiliser la bibliothèque \textsf{$<$math.h$>$} qui contient la fonction de calcul de racine carrée \textsf{double sqrt(double);}. \newline
%				 Écrire une fonction \textsf{double point\_distance(struct Point, struct Point);} qui renvoie la distance euclidienne entre deux points.
%	 \item Définir une structure \textsf{struct Circle} qui modélise un cercle.
%	 \item Écrire une fonction \textsf{double point\_distance\_to\_circle\_center(struct Circle, struct Point);} qui renvoie la distance euclidienne entre le centre du cercle et le point passés en argument.
%	 \item Écrire une fonction \textsf{char point\_in\_circle(struct Circle, struct Point);} qui renvoie :
%				 \begin{itemize}
%					 \item 1 si le point est à l'intérieur du cercle
%					 \item 0 sinon
%				 \end{itemize}
%	 % \item Écrire une fonction \textsf{struct Point closest\_point\_of\_circle\_border(struct Circle, struct Point);} qui à tout point $A\in{\mathbb{R}^{2}_{f64}}$ et à tout cercle $\mathcal{C} = \{p\in{\mathbb{R}^{2}_{f64}}\ |\ \lVert{p - \omega}\rVert = r\}$ de centre $\omega$ et de rayon $r$ renvoie le point $p_{min}\in{\mathcal{C}}$ tel que $\lVert{A - p_{min}}\rVert = \underset{p\in{c}}{min}\left(\lVert{A - p}\rVert\right)$
%	 \item Écrire une fonction \textsf{double point\_distance\_to\_circle\_border(struct Circle, struct Point);} qui renvoie la plus petite distance d'un point à la bordure d'un cercle.
%	 \item Définir une structure \textsf{struct Ray} définissant une demi-droite.
%	 \item Écrire une fonction \textsf{struct Ray ray\_from\_angle(struct Point origin, double angle);} qui génère une demi-droite à partir d'un point d'origine et d'un angle en radians.
%	 \item Écrire une fonction \textsf{struct Point point\_on\_ray(struct Ray, double d);} qui renvoie le point de la demi-droite à la distance $d$ de l'origine.
%	 \item Écrire une fonction \textsf{struct Point raymarch\_single(struct Ray, struct Circle* circles, unsigned int n);} qui a comme paramètres :
%	 \begin{itemize}
%		 \item un rayon
%		 \item un tableau de \textsf{n} cercles qui représentent l'environnement procédural
%	 \end{itemize}
%	 et qui, en faisant avancer un point sur le rayon de la distance au bord de cercle le plus proche, calcul et renvoie le point d'``impact'' du rayon dans l'environnement. On peut supposer que :
%	 \begin{itemize}
%		 \item si la distance au bord de cercle le plus proche est inférieure à une constante $D_{min}$ arbitraire\footnote{par exemple 0.01} alors le rayon a touché un cercle
%		 \item si la distance au bord de cercle le plus proche est supérieure à une constante $D_{max}$ arbitraire\footnote{par exemple 100.0} alors le rayon est ``sorti'' de l'environnement et ne peut pas toucher de cercles
%	 \end{itemize}
%	 Dans les deux cas on peut arrêter le calcul.
%	 \item Écrire une fonction \textsf{struct Point* raymarching(struct Point origin, unsigned int rays\_number, struct Circle* circles, unsigned int n);} qui effectue l'algorithme de \textit{raymarching} pour \textsf{rays\_number} rayons équirépartis autour de l'origine et renvoie un tableau des \textsf{rays\_number} points d'impacts des rayons.
% \end{enumerate}
\end{document}