\documentclass[../../../main.tex]{subfiles}
\graphicspath{{sections/part2/images/}}
\begin{document}
La \textit{projection de type} (\textit{static cast} en anglais) est une opération unaire du langage C qui permet la conversion d'un variable d'un type à un autre.
 
L'exemple suivant, extrêmement simple, va servir d'illustration à la projection de type : on souhaite diviser un nombre stocké comme un \underline{entier} par un diviseur stocké comme un \underline{entier}, et obtenir le nombre \underline{flottant} résultant. C'est-à-dire ne pas effectuer une division entière mais réelle.
 
On essaie dans un premier temps le code suivant :
\begin{minted}[linenos=false]{c}
int some_integer = 7851;
int divider = 100;
double a = some_integer/divider;
printf("%.2lf\n", a);
\end{minted}
Après exécution, on a le résultat : \textsf{78.00}
 
Le problème se situe au calcul \textsf{some\_integer/100}. En effet, l'opération effectuée est une division entière. Le résultat de cette division est donc $78$, qui est ensuite convertit implicitement en \textsf{double} par l'opérateur $=$. \newline
Il faudrait que la division effectuée ne soit pas une division entière. Pour cela, il est nécessaire de modifier l'interprétation d'au moins une des deux variables (\textsf{some\_integer} ou \textsf{divider}) pour qu'elle soit interprétée comme un \textsf{double} AVANT la division. On ne souhaite cependant pas modifier le type d'une des deux variables de manière définitive.
 
La solution à cela est la \textit{projection de type}. Il s'agit de forcer le compilateur à réinterpréter/convertir la variable en un autre type que celui auquel elle a été assignée. La syntaxe est la suivante :
\begin{minted}[linenos=false]{c}
TYPE1 variable;
TYPE2 reinterpreted_variable = (TYPE2)(variable);
\end{minted}
\textbf{IMPORTANT :} La projection de type effectue dans certains cas un changement de valeur sans modification de la donnée (c'est-à-dire du mot binaire) et dans d'autres cas un changement de la donnée pour rester au plus proche de l'ancienne valeur\footnote{Parce-que le langage C est conceptuellement claqué au sol, mais \textit{trènkile}.}. Ainsi :
\begin{itemize}
	\item projection de nombre à virgule vers entier : donnée modifiée et valeur approximée de l'ancienne (car perte de décimales)
	\item projection d'entier vers nombre à virgule : donnée modifiée et valeur approximée de l'ancienne (car perte de précision du fait de la norme IEEE 754)
	\item projection d'entier signé vers entier non signé, ou inversement : donnée non modifiée et valeur modifiée (simple changement d'interprétation)
	\item projection de pointeurs $T_1*$ vers $T_2*$ : donnée non modifiée\footnote{et c'est tout car la valeur et la donnée des pointeurs sont identiques}
\end{itemize}
Dans notre cas, il suffit d'écrire :
\begin{minted}[linenos=false]{c}
int some_integer = 7851;
int divider = 100;
double a = (double)(some_integer)/divider;
printf("%.2lf\n", a);
\end{minted}
Le résultat après exécution est bien : $78.51$

Dans le cas d'une projection d'un nombre entier non signé vers un nombre entier signé, on  a bien une simple réinterprétation : 
\begin{minted}[linenos=false]{c}
unsigned short int v = -1;
printf("%d\n", v); // -> 65535
printf("%d\n", (signed short int)(v)); // -> -1 mais il s'agit du même mot binaire
\end{minted}
\subsection{Exercices}
\exercise{Quelques évaluations entières}{13}\newline
Dire pour chaque expression si elle est vraie ou fausse (respectivement : différente ou égale à 0) :
\begin{minted}[linenos=false]{c}
int e1 = 0xFFFFFFF00 != 0xFFFFFFFF - (char)(-1);
int e2 = 0xFFFFFFFF - (unsigned char)(-1) - 0xFFFFFFF00;
int e3 = !(e1 == e2) || (1 ^ e2);
int e4 = (unsigned char)(!(((64 ^ e3) % 8) - 1) + 256) - 2;
int e5 = e1 && e3;
\end{minted}
\end{document}