\documentclass[../../main.tex]{subfiles}
\begin{document}
\section{Algorithmes et programmation} \label{sec:algorithmes_et_programmation}
La définition rigoureuse d'un algorithme se trouve n'être absolument pas trivial, ni même simple.
Une première raison à cela est qu'il s'agit d'un concept au départ considéré comme intuitif, et que la
formalisation d'un concept qui semble humainement intuitif pose immédiatement la question du bien
fondé et de la rigueur de cette formalisation : un mot est toujours interprété, et deux humains peuvent
utiliser le même mot, et ne pas en avoir la même utilisation, voir la même compréhension fine.

La difficulté sous-jacente à une telle définition sera tout à fait esquivé ici puisqu'elle nécessiterait
de poser une théorie du calcul pour définir \textit{formellement} ce qu'est un problème, ce que signifie la résolution d'un
problème, ainsi que la résolution en temps fini d'un problème, ce qu'est une instruction élémentaire,
etc\dots

On s'en passera en conservant une définition \textit{informelle}, c'est-à-dire \og avec les mains \fg{}, qui manque peut-être de rigueur mais qui a le bénéfice d'être simple et suffisante dans un cadre purement pratique.

\definition{Problème algorithmique (intuitivement)}{
	Si un problème doit être résolu par un algorithme, c'est qu'étant données certaines données d'entrée du problème, on veut \textit{produire effectivement} certaines données (en sortie donc) correspondant aux solutions du problème.

	Un problème est donc décrit en deux parties :
	\begin{itemize}
		\item la description des entrées possibles
		\item la description du résultat/des effets attendus selon l'entrée
	\end{itemize}
	À la section \ref{sec:calcul}, on assimilera ainsi un problème à une fonction de l'ensemble des entrées à l'ensemble des sorties.
}

\definition{Algorithme (intuitivement)}{
Un algorithme est une suite d'actions/d'instructions précises dont l'objectif est de résoudre un problème donné. Ces instructions doivent être les plus élémentaires possibles, et ne surtout pas être ambigües. C'est-à-dire qu'en lisant l'algorithme, il n'y ait qu'une seule possibilité d'action à chaque étape (ce qui ne signifie pas que le résultat soit prédéterminé puisqu'une action peut potentiellement avoir un résultat aléatoire, comme le lancer d'un dé par exemple).\\

À la section \ref{sec:calcul}, on définira plus précisement un algorithme comme la réalisation effective selon un modèle de calcul donné d'une fonction décrivant un problème.
}

\textbf{Exemple :} ``Changer la valeur d'un nombre'' n'est pas une instruction possible pour un algorithme, puisque le lecteur peut toujours \textit{interpréter} l'instruction, et ne sait en fait toujours pas exactement ce qu'il doit faire. Par contre l'instruction "Ajouter 1 à la valeur de la variable $x$" est une instruction, à condition que $x$ soit connue, que $1$ soit bien définie et que ``Ajouter'' soit une opération binaire bien définie sur $1$ et $x$.

Tout simplement.

\begin{algorithm}
\caption{Premier exemple simple}\label{alg:hello}
\KwIn{$\textit{Entier}:x$, $\textit{Entier}:y$}
\eIf {$x > y$} {
	\Return $x$\;
} {
	\Return $y$\;
}
\end{algorithm}

Cet algorithme est la réalisation effective de la fonction mathématique $max$ sur des entiers, qui peut être vue comme un problème à résoudre. Il n'est toutefois valide que si les opérations $>$ et \textbf{retourner} ont été décrites précisément en amont, \textit{pour éviter l'interprétation}. La définition d'un \textit{Entier} doit être également connue.

Un algorithme peut ensuite être exécuté par un \textit{agent}, et il produira alors un résultat donné.

\definition{Agent algorithmique}{Actionneur capable de communication qui lira l'algorithme écrit et effectuera les actions les unes à la suite des autres. Ce peut être un être humain, ou encore un chat ou un chien (par exemple en apprenant l'algorithme à haute voix au chien).\\

On dit que l'agent \textit{exécute} l'algorithme lorsqu'il effectue les actions décrites par l'algorithme.
}

Si il est exécuté par un ordinateur avec comme entrées les entiers $3$ et $4$, l'\textbf{Algorithme }\ref{alg:hello} produira donc le résultat suivant :

\begin{minipage}{1.\textwidth} \fontfamily{pcr}\selectfont
	4
\end{minipage}

L'intérêt d'algorithmes est notamment d'automatiser des tâches. On peut notamment imaginer l'algorithme suivant, dont une entrée est un paquet de pâte et dont la sortie associée est une casserole de pâtes cuites :

\begin{algorithm}
\caption{Cuisson des pâtes}\label{alg:letters}
Prendre une casserole\;
Mettre de l'eau dans la casserole\;
Mettre la casserole sur le feu\;
Allumer le feu sous la casserole\;
\Tq{l'eau ne bout pas} {
	Attendre que l'eau bout\;
}
Mettre les pâtes dans la casserole\;
Attendre 9 minutes\;
\end{algorithm}

On peut imaginer apprendre cet algorithme à notre singe de compagnie\footnote{C'est pas si con les singes\dots enfin\dots des pâtes ça doit pas être trop dur, non ?}, et simplement lui ordonner d'exécuter cet algorithme par l'instruction ``Va faire cuire les pâtes !''\footnote{Avec un siouplaît, c'est mieux, juste histoire de ne pas mettre sa bêtise sur le dos d'une vexation \textit{évidemment} injustifiée.}.

\textbf{Remarque :} En petit malin, le lecteur attentif peut observer\footnote{C'est la technique classique de ``Nan mais t'inquiètes, tu vois l'erreur là ? C'est juste pour voir si tu suis, et pas parce-que j'ai oublié.''\dots \textit{a priori} là ça va :)} que l'\textit{agent} qui exécute cet algorithme doit déjà savoir de quelle casserole, de quel feu, pâtes et eau il est question, pour qu'il n'y ait pas d'interprétation (et pour aller plus loin, il faut aussi qu'il comprenne le langage dans lequel est exprimé l'algorithme et le sens de chaque verbe/action, ce qui n'est pas toujours évident pour un singe).
\subsection{Algorithmes et programmes} \label{sub:algorithmes_et_programmes}
\definition{Programme}{Un programme informatique est un algorithme pouvant être exécuté par un ordinateur (qui est donc l'agent exécutant). Il doit donc être écrit dans un langage compréhensible par l'ordinateur appelé \textit{langage de programmation}.}

Dans la suite du chapitre, l'entièreté des algorithmes seront exécutés sur ordinateur, pour la principale raison que cela permet de visualiser les résultats et d'expérimenter par soi-même.

On va donc considérer pour toute la suite des programmes. Il faut cependant garder à l'esprit la distinction entre les deux, puisqu'un algorithme englobe beaucoup plus de choses qu'un programme informatique (il est difficile de programmer un ordinateur pour aller chercher le journal dans la boîte aux lettres ou pour faire cuire des pâtes).

Pour qu'un programme puisse être exécuté par un ordinateur, il doit être connu de celui-ci, et est donc stocké dans la mémoire de l'ordinateur. L'ordinateur va ensuite le lire instructions par instructions et exécuter chacune de ces instructions.

La représentation de l'algorithme doit donc être accessible à un ordinateur. On peut considérer une écriture de cette algorithme en langage binaire, c'est-à-dire comme une suite finie de 0 et de 1. La traduction du langage naturel (c'est-à-dire humain) en langage binaire est appellée \textit{compilation}. Elle est effectuée par des programmes appellées des \textit{compilateurs}.

\begin{center}
\includesvg[width=0.6\textwidth]{compilateur}
\captionof{figure}{Compilation d'un programme}\textit{\footnotesize (damn !\footnote{C'est vraiment le mot binaire correspondant à l'ajout de 42 dans le registre $\rm{AL}$ d'un processeur Intel !})}
\end{center}

On peut cependant généraliser un peu la notion de \textit{compilation} : on peut dire que compiler c'est lire une suite de caractères obéissant à une certaine syntaxe, en construisant une (autre) représentation de l'information que ces caractères expriment. De ce point
de vue, beaucoup d'opérations apparaissent comme étant de la compilation; à la limite, la lecture d'un nombre est déjà de la compilation, puisqu'il s'agit de lire des caractères constituant l'écriture d'une valeur selon la syntaxe des nombres décimaux et de fabriquer une autre représentation de la même information, à savoir sa valeur numérique \og dans notre tête \fg\footnote{Au sujet de la ``représentation cérébrale'' que nous avons des nombres, je recommande la lecture de Stanislas Dehaene\cite{BosseMathsDehaene}.}
\section{Langages de programmation} \label{sec:langages_de_programmation}
\subsection{Objectifs des langages de programmation} 
\label{sub:objectifs_des_langages_de_programmation}
Les langages dits \og de programmation \fg ont un objectif : la description de données.

Ces données peuvent être de multiples natures. Ce peut être :
\begin{itemize}
	\item un programme
	\item une page internet
	\item une base de relations entre données
	\item un fichier PDF comme celui-ci
	\item de la musique
	\item etc\dots
\end{itemize}
Il est à noter par ailleurs qu'un programme est potentiellement capable de décrire lui-même n'importe quel type information. Cependant, certains langages de programmation décrivent directement les données et non pas le programme qui les génère. On appelle les langages de programmation décrivant directement les données des \textit{langages de description}. Les langages décrivant des instructions exécutables par un ordinateur sont appellés des \textit{langages impératifs}.

\definition{Niveau d'abstraction}{
Les langages de programmation peuvent être plus abstraits, c'est-à-dire être proche ou non du fonctionnement technique de l'ordinateur. Un langage à haut niveau d'abstraction va cacher la technique associée à la manipulation du matériel de l'ordinateur (mémoire vive, périphériques, etc\dots) tandis qu'un langage à bas niveau d'abstraction va laisser la possibilité au programmeur de manipuler lui-même ce qui est ``matériel''. En fait, les langages à haut niveau d'abstraction écrivent les instructions de manipulation bas niveau à l'insu du programmeur.

\begin{minipage}{\textwidth}
	\begin{center}
		\includesvg[width=.45\textwidth]{abstraction_langages}
	\end{center}
\end{minipage}
}
\subsection{Langages compilés et interprétés} \label{sub:langages_compil_s_et_interpr_t_s}
Les langages de programmation peuvent être à nouveau divisés en deux catégories distinctes :
\begin{itemize}
	\item les langages compilés
	\item les langages interprétés
\end{itemize}
La compilation consiste à traduire un texte écrit dans un langage de programmation sous une forme accessible par un ordinateur, c'est-à-dire en langage binaire généralement.

Certains langages de programmation nécessitent d'être compilés pour que la donnée décrite puisse être traitée par l'ordinateur. Par exemple, la description en LaTex d'un document nécessite une compilation par un autre programme pour être codée au format PDF. Les langages C, C++ et Assembleur sont également des langages qui nécessitent un \textit{compilateur} pour être transformés/traduits en code binaire qui puisse être exécuté par un ordinateur.

L'autre catégorie de langages, dits interprétés, n'est jamais traduite en langage binaire pour être exécuté par l'ordinateur directement. Il y a à la place une interface créée par un autre programme appellé \textit{interpréteur}. Ce programme, qui lui est exécuté par l'ordinateur, va simuler l'exécution de l'ordinateur sur le code. Il va lire chacune des lignes du programme écrit, et va faire exécuter les instructions correspondantes à l'ordinateur. Cela permet notamment de créer un niveau d'abstraction supplémentaire pour le programmeur, qui n'a pas besoin de connaître sa machine pour écrire des programmes. C'est l'interpréteur qui s'occupe de l'aspect le plus technique. Le désavantage majeur de ce type de langages interprétés est que l'exécution d'un programme est beaucoup plus lente puisqu'une étape de traduction ``en direct'' par l'interpréteur est nécessaire \textbf{à chaque exécution du programme}. Ce type de langages n'a pu se développer efficacement que lorsque les ordinateurs ont été assez puissants pour le permettre.\footnote{\textit{Fun fact} : le langage interprété Lisp était très utilisé en intelligence artificielle au XX$^e$ siècle. Comme les ordinateurs généralistes de l'époque étaient trop lents, des ordinateurs spécialisés pour interpréter ce langages ont été développés : \href{https://fr.wikipedia.org/wiki/Machine_Lisp}{les machines Lisp}.} Cela explique par exemple l'explosion de Python dans le monde du développement ces dix dernières années.\footnote{Avis personnel de l'auteur : utiliser des langages qui consomment beaucoup plus de ressources pour arriver au même résultat avec des performances moindres pour des seules raisons de facilité est un problème dans un monde qui a besoin d'une baisse drastique de la consommation énergétique pour sa survie. Le Python ne permet pas de comprendre en profondeur les choses ni d'optimiser les programmes écrits de manière réellement efficace. Il n'est donc pas adapté pour des projets de grande envergure mais reste parfois utile pour tester une idée en cinq minutes. Certains argueront que le langage est utilisé à profusion dans le monde de l'industrie. Il s'agit pour moi d'une erreur à but lucrative mais non pérenne. À discuter\dots}
\section{Le langage C} \label{sec:le_langage_c}
Le langage C est un langage de bas niveau, c'est-à-dire qu'il est \textit{proche de la machine}. Cela signifie qu’il est nécessaire de bien comprendre l’organisation de la mémoire, la représentation des nombres et de manière générale le fonctionnement interne de l'ordinateur pour en tirer le meilleur parti et éviter certains les écueils inhérents à ce fonctionnement. D'un autre côté, il traduit assez bien dans sa syntaxe l'intuition algorithmique humaine et se trouve donc un moyen efficace d'apprendreà à programmer. Il est de plus très simple et présente peu de technicité langagière pure (au contraire de langages comme le Rust ou le Java par exemple).

En cela, l'apprentissage du C permet une meilleure compréhension et un apprentissage facilité des autres langages de programmation.

Le C a été inventé dans les années 70 aux Bell Labs par Denis Ritchie pour lequel il a reçu la \textit{IEEE Richard W.Hamming Medal}\footnote{La médaille Richard-Hamming est décernée chaque année depuis 1988 par l'\href{https://fr.wikipedia.org/wiki/Institute_of_Electrical_and_Electronics_Engineers}{IEEE}, pour honorer les contributions exceptionnelles à l'informatique et aux technologies de l'information.}. dans l'objectif particulier de développer des systèmes d'exploitation. En effet, son rapprochement avec la machine, son extrême modularité, sa syntaxe claire et précise\footnote{Là j'avoue j'abuse\dots y a des trucs en C qui ont été \textit{designed} avec les pieds. Genre les tableaux statiques par exemple\dots Mais chuuut !} et la possibilité d'inclure des fragments de programmes écrits en assembleur à l'intérieur de programmes écrits en C permettent de développer n'importe quel type d'application complexe avec une certaine facilité pour l'époque. Le C reste très utilisé dans les systèmes embarquées, le développement de systèmes d'exploitation et de nombreux domaines scientifiques et technologiques. Pour tout un tas de raisons allant du manque de souplesse abstraite du langage à certaines failles de sécurité introduites par les programmeurs rêveurs\footnote{Qui se trouvent être suffisamment nombreux pour avoir une mauvaise influence sur la réputation du langage\dots}, le langage C a tendance à être remplacé pour le développement d'applications complexes par d'autres langages qui proposent certaines solutions abstraites\footnote{comme la programmation orientée objets}, tiennent plus la main au programmeur en terme de sécurité\footnote{On pourra penser au \textit{garbage collector} introduit dans quantité de langages} et/ou de stabilité de développement\footnote{Il faut entendre : cette fois-ci le \textit{design} de base du langage est correct.}, proposent plus de fonctionnalités pré-écrites\footnote{Il n'y a qu'à voir la taille de la bibliothèque standard du C++ par rapport à celle du C}, etc\dots
\subsection{Installer un éditeur et un compilateur}\label{sub:installer_un_diteur_et_un_compilateur}
Avant de pouvoir programmer en C, il est nécessaire d'installer certains outils de base.
\subsubsection{Éditeur de texte}\label{ssub:_diteur_de_texte}
Le premier est l'éditeur de texte incluant la coloration syntaxique (\textit{syntax highlighting} en anglais), nécessaire pour la programmation quelque soit le langage utilisé. En effet, la coloration syntaxique permet de reconnaître les éléments du langage facilement et rend le code beaucoup plus lisible.
\begin{lstlisting}[title=Un premier programme]
\end{lstlisting}
\begin{minted}{c}
#include <stdio.h>

int main(int argc, char **argv) {
	printf("Hello World !\n");
	return 0;
}
\end{minted}
Les différents éléments du programme sont directement visibles.

Il existe deux grandes familles d'éditeurs de code :
\begin{itemize}
	\item Les Environnements de Développement Intégrés (EDIs) : en général spécialisés dans un unique langage de programmation, ils incluent le compilateur/interpréteur de celui-ci et tous les outils nécessaires pour programmer dans ce langage.
	\item Les éditeurs de texte : permettent d'éditer n'importe quel langage de programmation, mais ne fournissent aucun outil de compilation/interprétation, qui doit être installé à part (\textit{recommandé, car l'apprentissage de la compilation ``à la main'' est utile et même nécessaire dans de nombreux cas})
\end{itemize}
Il existe plusieurs EDIs/éditeurs de code connus qui permettent d'éditer des programmes dans la plupart des langages de programmation. On se restreindra ici à Sublime Text, un éditeur de texte simple mais complet : \url{https://www.sublimetext.com/download}. Visual Studio Code est aussi une possibilité, probablement plus connue : \url{https://code.visualstudio.com/}.
\subsubsection{Interface en ligne de commande} \label{ssub:interface_en_ligne_de_commande}
La plupart des ordinateurs proposent ajourd'hui aux utilisateurs \textit{lambda}\footnote{Sans rien de péjoratif, précisons.} une interface graphique pensée pour l'utilisation d'une souris, avec des boutons sur lesquelles cliquer. Pourtant, cela n'est que relativement récent (début des années 1980). L'interface graphique n'a été pensé initialement que pour la mise sur marché d'ordinateurs au grand public. En particulier, de nombreuses possibilités d'interactions, de natures techniques, avec l'ordinateur ne peuvent effectués grâce à l'interface graphique des systèmes d'exploitations comme Linux ou Windows.

Il faut pour pouvoir utiliser pleinement son ordinateur revenir aux outils accessibles par l'interface en ligne de commande (\textit{command line interface} en anglais). Cela est particulièrement nécessaire pour des systèmes Unix (comme Linux par exemple) qui ont d'abord été pensé à travers ce prisme (contrairement à Windows qui est pensé pour l'interface graphique).

\textbf{Sous Linux :} on peut ouvrir généralement une interface en ligne de commande grâce au raccourci clavier \textsf{CTRL + ALT + T} (c'est-à-dire l'appui simultané des touches \textsf{CTRL}, \textsf{ALT} et de la lettre \textsf{T})

\textbf{Sous Windows :} on peut ouvrir une interface en ligne de commande grâce au raccourci clavier \textsf{Windows + R} et en tapant dans la fenêtre qui apparaît soit \textsf{cmd}, soit \textsf{powershell}.
\subsubsection{Compilateur} \label{ssub:compilateur}
\textbf{Sous Linux :}

Un compilateur du langage C peut-être installé \textit{via} l'interface en ligne de commande :
\begin{minted}[linenos]{bash}
user@computer ~> sudo apt-get update && sudo apt-get upgrade
user@computer ~> sudo apt-get install gcc
user@computer ~> gcc -v
NUMERO DE VERSION AFFICHÉE SI INSTALLATION CORRECTE
\end{minted}

\textbf{Sous Windows :}

Pour installer un compilateur indépendant sous Windows, il suffit de télécharger l'archive à l'adresse : \url{https://github.com/brechtsanders/winlibs_mingw/releases/download/14.1.0posix-18.1.5-11.0.1-ucrt-r1/winlibs-x86_64-posix-seh-gcc-14.1.0-llvm-18.1.5-mingw-w64ucrt-11.0.1-r1.zip} puis d'extraire l'archive dans \textsf{C:/} de sorte à avoir un répertoire \textsf{C:/mingw64/}.

Le compilateur est alors dans le répertoire \textsf{C:/mingw64/bin/} et pourra être utilisé pour compiler les programmes écrits en C ou en C++.
\subsection{Compiler le premier programme} \label{sub:compiler_le_premier_programme}
Le code du premier programme doit être écrit dans un fichier de nom quelconque (appelé \textit{``main.c''} par convention).

Pour la suite, on pourra utiliser l'arborescence de fichiers suivante\footnote{Vous êtes bien sûr libre de faire autrement, il s'agit simplement de poser une structure conventionnelle pour la suite du cours.} :
\begin{center}
\begin{forest}
[Documents
	[Apprendre\_le\_C
		[src
			[main.c]
		]
	]
]
\end{forest}
\end{center}
Le répertoire ``src''\footnote{Pour ``source''} contiendra les fichiers de code \textit{C}. Cette arborescence sera développée et étendue dans par la suite.

\textbf{Sous Linux :}

Il suffit ensuite d'écrire dans l'interface en ligne de commande :
\begin{lstlisting}[title=Compiler sous Linux]
\end{lstlisting}
\begin{minted}[linenos]{bash}
user@computer ~> cd ~/Apprendre_le_C
user@computer ~/Apprendre_le_C> gcc src/main.c -o main --pedantic
user@computer ~/Apprendre_le_C> ./main
\end{minted}

\textbf{Sous Windows :}

Il suffit d'écrire dans l'interface en ligne de commande :
\begin{lstlisting}[title=Compiler sous Windows]
\end{lstlisting}
\begin{minted}[linenos]{batch}
C:\Users\user> cd Documents/Apprendre_le_C
C:\Users\user\Documents\Apprendre_le_C> C:/mingw64/bin/gcc.exe src/main.c -o main.exe
C:\Users\user\Documents\Apprendre_le_C> main.exe
\end{minted}
\og user \fg{} désigne votre nom d'utilisateur. Si une erreur apparaît à la première ligne, il faut taper \textsf{Utilisateurs} au lieu de \textsf{Users} (le système peut être en français).

\textbf{Dans les deux cas :}

La ligne 1 modifie le répertoire de travail du terminal. \newline
La ligne 2 compile notre programme sous la forme d'un exécutable appelé ``main.exe'' ou ``main''\footnote{``-o'' signifie \textit{output} et ``pedantic'' spécifie au compilateur d'être intransigeant avec la spécification standard du langage.}\newline
La ligne 3 commande à l'ordinateur d'exécuter le programme ``main.exe'' ou ``main'' au sein du terminal.

Le résultat devrait être l'affichage du texte ``Hello World !'' à l'écran.
\subsection{Analyse du premier programme} \label{sub:analyse_du_premier_programme}
On rappelle le premier programme écrit en C :
\begin{lstlisting}[title=Un premier programme]
\end{lstlisting}
\begin{minted}{c}
#include <stdio.h>

int main()
{
	printf("Hello World !\n");
	return 0;
}
\end{minted}
Bien qu'il s'agisse d'un programme très simple, il pose les fondements du langage par bien des aspects. L'une des premières tâches à effectuer lors de la découverte d'un language est d'apprendre les nombreux \textit{mot-clés} et symboles du langage de programmation. Une fois que vous aurez appris la signification sous-jacente au code, vous serez en mesure de ``parler'' au compilateur et de lui donner vos propres ordres et de construire n'importe quel type de programme que vous êtes assez inventif et ingénieux pour créer\footnote{Avec certaines contraintes théoriques et pratiques}. Le compilateur va ensuite le transformer en langage binaire et l'ordinateur l'exécutera.

Mais il est à noter que connaître la signification des symboles arcaniques du langage n'est pas tout ce qu'il y a à faire en programmation. Vous ne pouvez pas maîtriser une autre langue en lisant un dictionnaire de traduction. Pour parler couramment une autre langue, il faut s'entraîner à converser dans cette langue. L'apprentissage d'un langage de programmation n'est pas différent. Il faut s'entraîner à ``parler'' au compilateur avec le code source écrit. Tous les codes écrits dans ce cours doivent être retapés à la main (sans copié-collé qui n'apprend rien) et il ne faut pas hésiter à les expérimenter et les modifier avec curiosité.

\subsubsection{Analyse ligne par ligne} \label{ssub:analyse_ligne_par_ligne}
\begin{minted}[linenos=false]{c}
#include <stdio.h>
\end{minted}
Cette première ligne présente un aspect très puissant du langage C (toujours présent dans une certaine mesure dans les autres langages de programmation impératifs) : la \textit{modulation}.

La modulation consiste à diviser un programme en plusieurs ensembles de sous-programmes appelés \textit{modules} (\textit{modules} en anglais) qui vont chacun définir des fonctionnalités. Ces fonctionnalités sont ensuite utilisés dans un programme principal. Ce découpage permet de structurer un programme. Dans le cas de très gros projets (de plusieurs milliers, dizaines de milliers voire centaines de milliers de lignes de code\footnote{Les systèmes d'exploitation comme Linux ou Windows, ou encore les très gros logiciels comme les éditeurs de jeux vidéos tapent plutôt dans les quelques millions de lignes de code}), ce découpage est obligatoire pour pouvoir se retrouver dans le programme et savoir où les fonctionnalités ont été développés. On peut y penser comme à la fabrication d'un avion. L'entreprise Airbus ne fabrique pas l'intégralité de ses avions au même endroit. Il s'agit pour une part de l'assemblage de différents composants (ici les modules) construit à des endroits différents (parfois par des entreprises différentes).

Un \textit{bibliothèque} (\textit{library} en anglais) est une collection de modules.

Le langage C présente une très grande quantité de fonctionnalités qui ont déjà été programmés et qu'il suffit de ré-utiliser. Pour ne pas avoir à surcharger notre programme avec des fonctionnalités inutiles, il est possible de choisir les fonctionnalités incluses. Cela se fait par l'instruction \textsf{\#\detokenize{include}} qui permet d'inclure le contenu d'un module choisi. Par ``inclure'', il faut entendre : copier l'ensemble du code écrit dans le module dans notre programme.

Le module \textsf{stdio} est un module de la bibliothèque \textit{\underline{st}an\underline{d}ard} pour les entrées/sorties (\underline{I}nput/\underline{O}utput). Une bibliothèque dite standard est une bibliothèque présente par défaut dans le langage, présente à son installation. En C, les modules de cette bibliothèque sont indiqués entre chevrons \textsf{$<$nom\_module.h$>$}. Un module non standard (c'est-à-dire définie par le programmeur) est indiqué entre guillemets \textsf{"nom\_module.h"}.

Les informations nécessaires de ces modules sont stockés dans des fichiers dit d'entête (\textit{\underline{h}eaders} en anglais) qui finissent par l'extension \textit{.h}. Ce sont ces informations qui sont données pour permettre l'inclusion du code. Ces fichiers sont à différencier des fichiers d'extension \textit{.c} qui définissent les fichiers de code du langage C (l'extension d'un fichier de code est modifié en fonction du langage de programmation : \textit{py} en Python, \textit{java} en Java, etc\dots)
\begin{minted}[linenos=false]{c}
int main()
\end{minted}
Cette instruction permet de définir la fonction principale (\textit{main} en anglais signifie principal(e)). Une fonction en informatique est un algorithme avec certains paramètres appelés des entrées et qui renvoie une certaine valeur appelée sortie. Le concept de fonction en informatique est donc le même qu'en mathématiques.

La fonction \textsf{main} est celle qui est appelée à l'exécution du programme. En ceci, son adresse en mémoire définit le \textit{point d'entrée} du programme, c'est-à-dire l'adresse à laquelle débute l'exécution du programme.

On appelle \textit{type de retour d'une fonction} le type de la valeur en sortie de la fonction. Ici, ce type est \textsf{int}, c'est-à-dire \textit{\underline{int}eger} en anglais, qui signifie ``entier''. La fonction \textsf{main} renvoie donc un entier. L'entier renvoyé par la fonction \textsf{main} représente l'état du programme à la fin de son exécution. En général, 0 signifie que tout s'est bien passé, et $-1$ signifie qu'une erreur a eu lieu au cours de l'exécution du programme.

Les parenthèses contiennent les paramètres de la fonction définie. On observe que dans ce cas-ci, la fonction \textsf{main} n'a aucun paramètre.
\begin{minted}[linenos=false]{c}
{
...
}
\end{minted}
Les accolades définissent un \textit{bloc de code}. Ce bloc est associé à la fonction \textsf{main}. Il contient l'algorithme exécuté par cette fonction.
\begin{minted}[linenos=false]{c}
printf("Hello World !\n");
\end{minted}
Cette instruction appelle la fonction \textsf{printf} écrite dans le module d'entrée/sortie \textsf{stdio} inclue plus haut. Cette fonction sert à afficher du texte sur un terminal de commande. Le caractère ``$\setminus$n'' représente le retour à la ligne.
\begin{minted}[linenos=false]{c}
return 0;
\end{minted}
L'instruction \textsf{return} renvoie la sortie de la fonction écrite. Ici, la sortie de la fonction \textsf{main} est 0, c'est-à-dire que tout s'est bien passé. En général, le \textsf{return} à la fin de la fonction \textsf{main} renvoie toujours 0. En effet, si on est arrivé à la fin du programme, c'est qu'il n'y a pas eu de problème. On renvoie un code d'erreur seulement si une erreur nous empêche d'aller plus loin.
\end{document}